{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"section/EntLinux/","text":"En estos primeros pasos veremos algunos conceptos muy b\u00e1sicos que es necesario dominar previo a adquirir cualquier conocimiento relativo a la seguridad de sistemas. Estas nociones b\u00e1sicas nos dar\u00e1n las herramientas principales para desenvolvernos dentro de un sistema y entender los principios de ciberseguridad que se presentar\u00e1n con posterioridad. Estructura de ficheros Un sistema de archivos, llamado com\u00fanmente File System o FS, determina la organizaci\u00f3n de los datos en un soporte de almacenamiento, y por tanto, c\u00f3mo gestiona y organiza el sistema operativo los archivos. Linux es, como todo Unix, un sistema operativo completamente orientado a archivos. Se representa todo (o casi todo) con un archivo, tanto los datos (archivos de datos de cualquier tipo, como una imagen o un programa) como los perif\u00e9ricos (terminales, ratones, teclado, tarjeta sonido, etc.) o incluso los medios de comunicaci\u00f3n (sockets, tuber\u00edas nombradas, etc.). Se puede decir que el sistema de archivos es el coraz\u00f3n de cualquier sistema Unix. Un archivo es una entidad que almacena datos y programas. Se compone de contenido y metadatos (tama\u00f1o del archivo, propietario, fecha de creaci\u00f3n, permisos). Los archivos est\u00e1n organizados en directorios. Un directorio es un archivo que almacena otros archivos. Los diferentes tipos de archivos incluyen: Archivos regulares que almacenan datos y programas. Directorios que contienen otros archivos. Archivos especiales que se utilizan para entrada y salida. Todo en Linux es un archivo , por lo que saber c\u00f3mo manipularlos es muy importante. As\u00ed pues, en la secci\u00f3n correspondiente, veremos las operaciones b\u00e1sicas con archivos mediante el terminal. El sistema de archivos de Linux es jer\u00e1rquico. Describe un \u00e1rbol de directorios y subdirectorios, a partir de un elemento b\u00e1sico llamado ra\u00edz o root directory. Usuarios y grupos Un usuario es cualquiera que use un ordenador. En este caso, estamos describiendo los nombres que representan a esos usuarios. Puede ser Pol o Mart\u00ed, y pueden usar los nombres superc0der o Pirate en lugar de su nombre real. Lo \u00fanico que importa es que la computadora tenga un nombre para cada cuenta que cree, y es este nombre por el que una persona obtiene acceso para usar la computadora. Algunos servicios del sistema tambi\u00e9n se ejecutan utilizando cuentas de usuario restringidas o privilegiadas. La administraci\u00f3n de los usuarios se realiza con fines de seguridad al limitar el acceso de ciertas maneras espec\u00edficas. El superusuario (root) tiene acceso completo al sistema operativo y su configuraci\u00f3n; est\u00e1 destinado solo para uso administrativo. Los usuarios sin privilegios pueden usar los programas su y sudo para la escalada de privilegios controlada. Cualquier persona puede tener m\u00e1s de una cuenta, siempre que utilicen un nombre diferente para cada una de ellas. Adem\u00e1s, hay algunos nombres reservados que no se pueden usar, como \u00abroot\u00bb. Los usuarios pueden aglutinarse en un \u00abgrupo\u00bb y, del mismo modo, pueden a\u00f1adirse a un grupo existente para utilizar el acceso privilegiado que dicho grupo concede. Los grupos de usuarios juegan un papel esencial en los sistemas Linux. Gracias a ellos tenemos una manera muy f\u00e1cil de seleccionar grupos de usuarios a los que se les permite compartir archivos entre ellos. Tambi\u00e9n proporcionan a los administradores de sistemas una manera m\u00e1s efectiva y sencilla de gestionar los privilegios de los usuarios puesto que permiten asignar privilegios a grupos completos en lugar de a usuarios individuales. Permisos Aunque hay multitud de caracter\u00edsticas de seguridad integradas en los sistemas basados \u200b\u200ben Linux, puede existir una vulnerabilidad potencial muy importante cuando se otorga el acceso al sistema a los usuarios. Pueden aparecer problemas cuando no se han asignado los permisos adecuados a los archivos y directorios. Grupos de permisos Cada archivo y directorio tiene tres grupos de permisos basados \u200b\u200ben usuarios: Propietario: los permisos de propietario se aplican solo al propietario del archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Grupo: los permisos de grupo se aplican solo al grupo que se ha asignado al archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Todos los usuarios: los permisos de todos los usuarios se aplican a todos los dem\u00e1s usuarios del sistema; este es el grupo de permisos que m\u00e1s desea ver. Tipos de permisos Cada archivo o directorio tiene tres tipos de permisos b\u00e1sicos: Lectura (read/r): el permiso de lectura se refiere a la capacidad de un usuario para leer el contenido del archivo. El permiso de lectura en un directorio permite listar su contenido. Escritura (write/w): los permisos de escritura se refieren a la capacidad de un usuario para escribir o modificar un archivo. En un directorio permite crear, eliminar o modificar el nombre de un archivo. En un hipot\u00e9tico caso donde tuvi\u00e9ramos permiso de escritura en un archivo pero no en el directorio en el que est\u00e1 ubicado, podr\u00edamos modificar el contenido del archivo pero no su nombre, ni moverlo de sitio, ni eliminarlo del directorio. Ejecuci\u00f3n (execution/x): el permiso de ejecuci\u00f3n afecta la capacidad de un usuario para ejecutar un archivo o ver el contenido de un directorio. Tip Podemos inspeccionar con detalle los permisos de arhivos y directorios con el comando: ls -l \u00bfC\u00f3mo se cambian los permisos en Linux? Para cambiar los permisos de archivos y directorios en GNU/Linux, disponemos de 3 comandos principales: chmod: cambiar permisos del archivo o directorio: chmod [ permisos ][ archivo/directorio ][ opciones ] chown: cambiar el propietario del archivo o directorio: chown [ nuevo usuario propietario ][ archivo/directorio ][ opciones ] chgrp: cambiar el grupo del archivo o directorio: chgrp [ nuevo grupo ][ archivo/directorio ][ opciones ] Existen dos formas de cambiar los permisos de archivos y directorios en Linux: Modo simb\u00f3lico: con notaci\u00f3n basada en caracteres Modo absoluto: con notaci\u00f3n num\u00e9rica, seg\u00fan el sistema octal o en base 8 , cuyos valores de forma resumida puedne verse en la imagen a continuaci\u00f3n: As\u00ed pues, una tabla resumen en cu\u00e1nto a los permisos vistos, ser\u00eda la siguiente: Valor Permisos Descripci\u00f3n 0 --- Sin permisos 1 --x Ejecuci\u00f3n 2 -w- Lectura 3 -wx Lectura + ejecuci\u00f3n 4 r-- Lectura 5 r-x Lectura + ejecuci\u00f3n 6 rw- Lectura + escritura 7 rwx Lectura + escritura + ejecuci\u00f3n Los permisos utilizando la notaci\u00f3n num\u00e9rica en sistema octal, se asignan en tuplas de 3 (usuario/grupo/otros) y no es posible asignar s\u00f3lo para uno o dos de los elementos de la tupla. Algunos ejemplos de permisos en modo absoluto son: Notaci\u00f3n Significado rw------- (600) Permisos de lectura y escritura s\u00f3lo para el propietario rw-r--r-- (644) Permisos de lectura y escritura s\u00f3lo para el propietario y s\u00f3lo de lectura para el grupo y resto de usuarios rwxr-xr-x (755) Permisos de lectura, escritura y ejecuci\u00f3n para el usuario y de lectura y ejecuci\u00f3n para el grupo y resto de usuarios rwxrwxrwx (777) Usuario, grupo y resto de usuarios tienen todos los permisos sobre el fichero o directorio (\u00a1Cuidado!) rw-rw-rw- (666) Usuario, grupo y resto de usuarios pueden leer y escribir sobre el fichero o directorio(\u00a1cuidado!) Como ya hemos dicho es el comando chmod el utilizado en el terminal para cambiar los permisos de los usuarios. Puede usarse tanto con el modo absoluto como con el simb\u00f3lico. Un ejemplo para el formato absoluto ser\u00eda: chmod 600 archivo/directorio Y para el formato con caracteres chmod ugo+rw archivo/directorio Donde, en este \u00faltimo caso, los permisos rwx (lectura/escritura/ejecuci\u00f3n) pueden asignarse a: u - propietario g - grupo o - otros a - todos los usuarios Si utilizamos el operador + estaremos agregando permisos, si usamos el - los eliminaremos: chmod a-rw archivo1 chmod u+rwx archivo2 Ejemplos pr\u00e1cticos del uso de chmod para cambiar permisos de un archivo. Podemos utilizar tanto la forma absoluta, como la simb\u00f3lica: Modo absoluto Modo simb\u00f3lico Resultado chmod 700 archivo.gpg chmod u+rwx -rwx------ chmod 555 chmod ugo+rx -r-xr-xr-x chmod 666 -chmod ugo+rw rw-rw-rw- Permisos avanzados En GNU/Linux, adem\u00e1s de los 3 que hemos visto anteriormente, todav\u00eda existen otros tres permisos especiales adicionales que veremos a continuaci\u00f3n. Bit setuid En Linux, de forma predeterminada, cuando un usuario ejecuta un archivo, el archivo se inicia con los privilegios del usuario que lo ejecuta. Sin embargo, este comportamiento se puede cambiar si establecemos permisos especiales en archivos ejecutables. Setuid significa \"establecer ID de usuario\". Si configuramos el bit setuid en un archivo ejecutable, el archivo siempre se ejecuta con los privilegios del propietario del archivo, sin importar qui\u00e9n lo inicie. El bit setuid solo tiene sentido si est\u00e1 configurado en archivos ejecutables. No hay ning\u00fan significado pr\u00e1ctico si configuramos el bit setuid en un archivo o directorio no ejecutable. El comando passwd es un ejemplo con este bit especial aplicado: $ ls -l /bin/passwd -rwsr-xr-x 1 root root 63624 Dec 15 21:06 /bin/passwd Observamos que el permiso de ejecuci\u00f3n para el propietario es una \"s\" min\u00fascula en lugar de la \"x\" habitual. Esta \"s\" indica que el archivo tiene el bit setuid establecido. El comando passwd siempre se ejecutar\u00e1 con privilegios de root sin importar qui\u00e9n lo inicie porque el propietario del archivo es root. Como ya sabemos, podemos usar el comando chmod para establecer el bit setuid en un archivo: chmod u+x archivo S\u00f3lo el propietario el archivo o el usuario o el usuario root puede establecer el bit setuid Un ejemplo pr\u00e1ctico de c\u00f3mo configurar este bit setuid en un archivo, de forma simb\u00f3lica: $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12:22 archivo $ chmod u+s archivo $ ls -l archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12:22 archivo En el modo absoluto, anteponemos un 4 a los permisos para indicar este bit: $ chmod 4755 archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12:22 archivo Y para quitar este bit, en ambos modos: $ chmod u-s archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12:22 archivo y $ chmod 0755 archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12:22 archivo Riesgo de seguridad El bit setuid podr\u00eda ser bastante \u00fatil en varias aplicaciones. Sin embargo, debemos tener cuidado al establecer esos permisos especiales, ya que pueden crear problemas de seguridad. Por ejemplo, un usuario normal puede obtener privilegios de superusuario ejecutando un programa que establece el UID como root y realizar una escalada de privilegios. Bit setgid Bit setgid en un archivo setgid es la abreviatura de \"set group id\". Si configuramos el bit setgid en un archivo ejecutable, no importa qui\u00e9n inicie el archivo, se ejecuta con los privilegios del grupo propietario. El comando de localizaci\u00f3n es un ejemplo de un archivo con el conjunto de bits setgid : $ ls -l /usr/bin/locate -rwxr-sr-x 1 root locate 43048 Nov 13 18:09 /usr/bin/locate Similar al bit setuid , notamos una \"s\" min\u00fascula en la salida de ls , excepto que est\u00e1 en la secci\u00f3n de grupo en lugar de en la secci\u00f3n de propietario. Para establecer este bit de modo simb\u00f3lico podemos utilizar: $ ls -l archivo2 -rwxr-xr-x 1 raul raul 0 Feb 2 22:35 archivo2 $ chmod g+s archivo2 $ ls -l archivo2 -rwxr-sr-x 1 raul raul 0 Feb 2 22:35 archivo2 Y de modo absoluto, anteponiendo un dos a los permisos: chmod 2755 archivo2 Bit setgid en un directorio Si configuramos el bit setgid en un directorio, todos los archivos y subdirectorios reci\u00e9n creados en el directorio heredar\u00e1n el grupo de ese directorio. Sin embargo, los archivos y directorios existentes no aplicar\u00e1n el cambio de grupo. Veamos un ejemplo para aclarar este comportamiento. Primero, preparamos un directorio padre que contiene dos archivos: $ ls -ld padre drwxrwxrwx 2 root raul 4096 Feb 3 00:33 padre/ $ ls -l padre total 2 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 existing_grp_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 existing_grp_invitado2 padre es propiedad del usuario root y del grupo raul. Contiene dos archivos e invitado es due\u00f1o de ambos. A continuaci\u00f3n, establezcamos el bit setgid en padre usando chmod: root# chmod g+s padre root# ls -ld padre drwxrwsrwx 2 root raul 4096 Feb 3 00:33 padre/ Ahora, vamos a crear un nuevo archivo y un subdirectorio bajo el padre con root: root# touch padre/nuevo_root root# mkdir padre/nuevo_dir_root``` Luego, verificaremos los propietarios del grupo de todos los archivos y subdirectorios en padre: root# ls -l padre total 4 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 grp_exist_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 grp_exist_invitado2 drwxr-sr-x 2 root raul 4096 Feb 3 00:54 nuevo_dir_root/ -rw-r--r-- 1 root raul 0 Feb 3 00:54 nuevo_arch_root En la salida anterior, vemos que los dos archivos existentes no han cambiado despu\u00e9s de que establecemos el bit setuid en padre. Sin embargo, el archivo y el subdirectorio reci\u00e9n creados son propiedad de raul en lugar de root , aunque root los cre\u00f3. Esto se debe a que el padre ten\u00eda establecido el bit setgid , y los archivos y directorios reci\u00e9n creados bajo \u00e9l heredaron el grupo del padre. Sticky bit La misi\u00f3n del sticky bit es proteger los archivos dentro de un directorio. Si configuramos el sticky bit en un directorio, un archivo en este directorio solo se puede eliminar mediante una de las siguientes opciones: El due\u00f1o del archivo El due\u00f1o del directorio El usuario root En otras palabras, este permiso especial evita que un usuario elimine los archivos de otros usuarios en un directorio p\u00fablico. Un ejemplo t\u00edpico de sticky bit del mundo real es el directorio /tmp: $ ls -ld /tmp drwxrwxrwt 24 root root 980 Feb 3 21:41 /tmp/ Debido a la \"w\" en la secci\u00f3n de permisos \"otros\", sabemos que cualquier usuario puede crear y eliminar cualquier archivo en el directorio /tmp . Pero si leemos la salida de ls anterior con atenci\u00f3n, vemos que el bit de permiso de ejecuci\u00f3n en la secci\u00f3n \"otro\" es una \"t\" min\u00fascula, en lugar de la \"x\" habitual. Esta \"t\" en min\u00fascula indica que el directorio / tmp tiene el bit fijo establecido. Con el sticky bit, cualquier usuario a\u00fan puede crear archivos bajo /tmp. Sin embargo, un usuario solo puede eliminar archivos de su propiedad. El sticky bit en un directorio Para establecer el sticky bit en un directorio, a\u00fan podemos usar el comando chmod con el modo + t : chmod +t DIRECTORIO De otra forma, tambi\u00e9n podemos anteponer un \"1\" al modo de un directorio para establecer el sticky bit: chmod 1777 DIRECTORIO Tambi\u00e9n podemos eliminar el sticky bit de un directorio usando -t : chmod -t DIRECTORIO Como de costumbre, veamos un ejemplo para comprender c\u00f3mo el sticky bit puede proteger los archivos de un directorio y c\u00f3mo configurar y eliminar el sticky bit en un directorio. Comencemos por preparar un directorio p\u00fablico llamado p\u00fablico y permitir que todos los usuarios escriban en \u00e9l: $ ls -ld public drwxrwxrwx 2 root root 40 Feb 3 22:22 public/ A continuaci\u00f3n, crearemos algunos archivos en p\u00fablico por diferentes usuarios: $ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo1_invitado -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22:28 archivo_raul Hasta ahora, no hemos colocado el sticky bit en ninguna parte. Veamos si el usuario raul puede eliminar un archivo propiedad de un invitado: raul$ rm archivo1_invitado rm: remove write-protected regular empty archivo 'archivo1_invitado'? y raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22:28 archivo_raul Entonces, sin el sticky bit, podemos eliminar archivos propiedad de otros usuarios. Ahora, configuremos el sticky bit y veamos si hay alg\u00fan cambio: root# chmod +t public root# ls -ld public drwxrwxrwt 2 root root 80 Feb 3 22:33 public/ root# su raul raul$ rm archivo2_invitado rm: remove write-protected regular empty archivo 'archivo2_invitado'? y rm: cannot remove 'archivo2_invitado': Operation not permitted raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22:28 archivo_raul Despu\u00e9s de configurar el sticky bit, los archivos en p\u00fablico solo pueden ser eliminados por los propietarios del archivo. Principales comandos para manejarse en el terminal","title":"Entornos Linux"},{"location":"section/EntLinux/#estructura-de-ficheros","text":"Un sistema de archivos, llamado com\u00fanmente File System o FS, determina la organizaci\u00f3n de los datos en un soporte de almacenamiento, y por tanto, c\u00f3mo gestiona y organiza el sistema operativo los archivos. Linux es, como todo Unix, un sistema operativo completamente orientado a archivos. Se representa todo (o casi todo) con un archivo, tanto los datos (archivos de datos de cualquier tipo, como una imagen o un programa) como los perif\u00e9ricos (terminales, ratones, teclado, tarjeta sonido, etc.) o incluso los medios de comunicaci\u00f3n (sockets, tuber\u00edas nombradas, etc.). Se puede decir que el sistema de archivos es el coraz\u00f3n de cualquier sistema Unix. Un archivo es una entidad que almacena datos y programas. Se compone de contenido y metadatos (tama\u00f1o del archivo, propietario, fecha de creaci\u00f3n, permisos). Los archivos est\u00e1n organizados en directorios. Un directorio es un archivo que almacena otros archivos. Los diferentes tipos de archivos incluyen: Archivos regulares que almacenan datos y programas. Directorios que contienen otros archivos. Archivos especiales que se utilizan para entrada y salida. Todo en Linux es un archivo , por lo que saber c\u00f3mo manipularlos es muy importante. As\u00ed pues, en la secci\u00f3n correspondiente, veremos las operaciones b\u00e1sicas con archivos mediante el terminal. El sistema de archivos de Linux es jer\u00e1rquico. Describe un \u00e1rbol de directorios y subdirectorios, a partir de un elemento b\u00e1sico llamado ra\u00edz o root directory.","title":"Estructura de ficheros"},{"location":"section/EntLinux/#usuarios-y-grupos","text":"Un usuario es cualquiera que use un ordenador. En este caso, estamos describiendo los nombres que representan a esos usuarios. Puede ser Pol o Mart\u00ed, y pueden usar los nombres superc0der o Pirate en lugar de su nombre real. Lo \u00fanico que importa es que la computadora tenga un nombre para cada cuenta que cree, y es este nombre por el que una persona obtiene acceso para usar la computadora. Algunos servicios del sistema tambi\u00e9n se ejecutan utilizando cuentas de usuario restringidas o privilegiadas. La administraci\u00f3n de los usuarios se realiza con fines de seguridad al limitar el acceso de ciertas maneras espec\u00edficas. El superusuario (root) tiene acceso completo al sistema operativo y su configuraci\u00f3n; est\u00e1 destinado solo para uso administrativo. Los usuarios sin privilegios pueden usar los programas su y sudo para la escalada de privilegios controlada. Cualquier persona puede tener m\u00e1s de una cuenta, siempre que utilicen un nombre diferente para cada una de ellas. Adem\u00e1s, hay algunos nombres reservados que no se pueden usar, como \u00abroot\u00bb. Los usuarios pueden aglutinarse en un \u00abgrupo\u00bb y, del mismo modo, pueden a\u00f1adirse a un grupo existente para utilizar el acceso privilegiado que dicho grupo concede. Los grupos de usuarios juegan un papel esencial en los sistemas Linux. Gracias a ellos tenemos una manera muy f\u00e1cil de seleccionar grupos de usuarios a los que se les permite compartir archivos entre ellos. Tambi\u00e9n proporcionan a los administradores de sistemas una manera m\u00e1s efectiva y sencilla de gestionar los privilegios de los usuarios puesto que permiten asignar privilegios a grupos completos en lugar de a usuarios individuales.","title":"Usuarios y grupos"},{"location":"section/EntLinux/#permisos","text":"Aunque hay multitud de caracter\u00edsticas de seguridad integradas en los sistemas basados \u200b\u200ben Linux, puede existir una vulnerabilidad potencial muy importante cuando se otorga el acceso al sistema a los usuarios. Pueden aparecer problemas cuando no se han asignado los permisos adecuados a los archivos y directorios.","title":"Permisos"},{"location":"section/EntLinux/#grupos-de-permisos","text":"Cada archivo y directorio tiene tres grupos de permisos basados \u200b\u200ben usuarios: Propietario: los permisos de propietario se aplican solo al propietario del archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Grupo: los permisos de grupo se aplican solo al grupo que se ha asignado al archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Todos los usuarios: los permisos de todos los usuarios se aplican a todos los dem\u00e1s usuarios del sistema; este es el grupo de permisos que m\u00e1s desea ver.","title":"Grupos de permisos"},{"location":"section/EntLinux/#tipos-de-permisos","text":"Cada archivo o directorio tiene tres tipos de permisos b\u00e1sicos: Lectura (read/r): el permiso de lectura se refiere a la capacidad de un usuario para leer el contenido del archivo. El permiso de lectura en un directorio permite listar su contenido. Escritura (write/w): los permisos de escritura se refieren a la capacidad de un usuario para escribir o modificar un archivo. En un directorio permite crear, eliminar o modificar el nombre de un archivo. En un hipot\u00e9tico caso donde tuvi\u00e9ramos permiso de escritura en un archivo pero no en el directorio en el que est\u00e1 ubicado, podr\u00edamos modificar el contenido del archivo pero no su nombre, ni moverlo de sitio, ni eliminarlo del directorio. Ejecuci\u00f3n (execution/x): el permiso de ejecuci\u00f3n afecta la capacidad de un usuario para ejecutar un archivo o ver el contenido de un directorio. Tip Podemos inspeccionar con detalle los permisos de arhivos y directorios con el comando: ls -l","title":"Tipos de permisos"},{"location":"section/EntLinux/#como-se-cambian-los-permisos-en-linux","text":"Para cambiar los permisos de archivos y directorios en GNU/Linux, disponemos de 3 comandos principales: chmod: cambiar permisos del archivo o directorio: chmod [ permisos ][ archivo/directorio ][ opciones ] chown: cambiar el propietario del archivo o directorio: chown [ nuevo usuario propietario ][ archivo/directorio ][ opciones ] chgrp: cambiar el grupo del archivo o directorio: chgrp [ nuevo grupo ][ archivo/directorio ][ opciones ] Existen dos formas de cambiar los permisos de archivos y directorios en Linux: Modo simb\u00f3lico: con notaci\u00f3n basada en caracteres Modo absoluto: con notaci\u00f3n num\u00e9rica, seg\u00fan el sistema octal o en base 8 , cuyos valores de forma resumida puedne verse en la imagen a continuaci\u00f3n: As\u00ed pues, una tabla resumen en cu\u00e1nto a los permisos vistos, ser\u00eda la siguiente: Valor Permisos Descripci\u00f3n 0 --- Sin permisos 1 --x Ejecuci\u00f3n 2 -w- Lectura 3 -wx Lectura + ejecuci\u00f3n 4 r-- Lectura 5 r-x Lectura + ejecuci\u00f3n 6 rw- Lectura + escritura 7 rwx Lectura + escritura + ejecuci\u00f3n Los permisos utilizando la notaci\u00f3n num\u00e9rica en sistema octal, se asignan en tuplas de 3 (usuario/grupo/otros) y no es posible asignar s\u00f3lo para uno o dos de los elementos de la tupla. Algunos ejemplos de permisos en modo absoluto son: Notaci\u00f3n Significado rw------- (600) Permisos de lectura y escritura s\u00f3lo para el propietario rw-r--r-- (644) Permisos de lectura y escritura s\u00f3lo para el propietario y s\u00f3lo de lectura para el grupo y resto de usuarios rwxr-xr-x (755) Permisos de lectura, escritura y ejecuci\u00f3n para el usuario y de lectura y ejecuci\u00f3n para el grupo y resto de usuarios rwxrwxrwx (777) Usuario, grupo y resto de usuarios tienen todos los permisos sobre el fichero o directorio (\u00a1Cuidado!) rw-rw-rw- (666) Usuario, grupo y resto de usuarios pueden leer y escribir sobre el fichero o directorio(\u00a1cuidado!) Como ya hemos dicho es el comando chmod el utilizado en el terminal para cambiar los permisos de los usuarios. Puede usarse tanto con el modo absoluto como con el simb\u00f3lico. Un ejemplo para el formato absoluto ser\u00eda: chmod 600 archivo/directorio Y para el formato con caracteres chmod ugo+rw archivo/directorio Donde, en este \u00faltimo caso, los permisos rwx (lectura/escritura/ejecuci\u00f3n) pueden asignarse a: u - propietario g - grupo o - otros a - todos los usuarios Si utilizamos el operador + estaremos agregando permisos, si usamos el - los eliminaremos: chmod a-rw archivo1 chmod u+rwx archivo2 Ejemplos pr\u00e1cticos del uso de chmod para cambiar permisos de un archivo. Podemos utilizar tanto la forma absoluta, como la simb\u00f3lica: Modo absoluto Modo simb\u00f3lico Resultado chmod 700 archivo.gpg chmod u+rwx -rwx------ chmod 555 chmod ugo+rx -r-xr-xr-x chmod 666 -chmod ugo+rw rw-rw-rw-","title":"\u00bfC\u00f3mo se cambian los permisos en Linux?"},{"location":"section/EntLinux/#permisos-avanzados","text":"En GNU/Linux, adem\u00e1s de los 3 que hemos visto anteriormente, todav\u00eda existen otros tres permisos especiales adicionales que veremos a continuaci\u00f3n.","title":"Permisos avanzados"},{"location":"section/EntLinux/#bit-setuid","text":"En Linux, de forma predeterminada, cuando un usuario ejecuta un archivo, el archivo se inicia con los privilegios del usuario que lo ejecuta. Sin embargo, este comportamiento se puede cambiar si establecemos permisos especiales en archivos ejecutables. Setuid significa \"establecer ID de usuario\". Si configuramos el bit setuid en un archivo ejecutable, el archivo siempre se ejecuta con los privilegios del propietario del archivo, sin importar qui\u00e9n lo inicie. El bit setuid solo tiene sentido si est\u00e1 configurado en archivos ejecutables. No hay ning\u00fan significado pr\u00e1ctico si configuramos el bit setuid en un archivo o directorio no ejecutable. El comando passwd es un ejemplo con este bit especial aplicado: $ ls -l /bin/passwd -rwsr-xr-x 1 root root 63624 Dec 15 21:06 /bin/passwd Observamos que el permiso de ejecuci\u00f3n para el propietario es una \"s\" min\u00fascula en lugar de la \"x\" habitual. Esta \"s\" indica que el archivo tiene el bit setuid establecido. El comando passwd siempre se ejecutar\u00e1 con privilegios de root sin importar qui\u00e9n lo inicie porque el propietario del archivo es root. Como ya sabemos, podemos usar el comando chmod para establecer el bit setuid en un archivo: chmod u+x archivo S\u00f3lo el propietario el archivo o el usuario o el usuario root puede establecer el bit setuid Un ejemplo pr\u00e1ctico de c\u00f3mo configurar este bit setuid en un archivo, de forma simb\u00f3lica: $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12:22 archivo $ chmod u+s archivo $ ls -l archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12:22 archivo En el modo absoluto, anteponemos un 4 a los permisos para indicar este bit: $ chmod 4755 archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12:22 archivo Y para quitar este bit, en ambos modos: $ chmod u-s archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12:22 archivo y $ chmod 0755 archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12:22 archivo Riesgo de seguridad El bit setuid podr\u00eda ser bastante \u00fatil en varias aplicaciones. Sin embargo, debemos tener cuidado al establecer esos permisos especiales, ya que pueden crear problemas de seguridad. Por ejemplo, un usuario normal puede obtener privilegios de superusuario ejecutando un programa que establece el UID como root y realizar una escalada de privilegios.","title":"Bit setuid"},{"location":"section/EntLinux/#bit-setgid","text":"","title":"Bit setgid"},{"location":"section/EntLinux/#bit-setgid-en-un-archivo","text":"setgid es la abreviatura de \"set group id\". Si configuramos el bit setgid en un archivo ejecutable, no importa qui\u00e9n inicie el archivo, se ejecuta con los privilegios del grupo propietario. El comando de localizaci\u00f3n es un ejemplo de un archivo con el conjunto de bits setgid : $ ls -l /usr/bin/locate -rwxr-sr-x 1 root locate 43048 Nov 13 18:09 /usr/bin/locate Similar al bit setuid , notamos una \"s\" min\u00fascula en la salida de ls , excepto que est\u00e1 en la secci\u00f3n de grupo en lugar de en la secci\u00f3n de propietario. Para establecer este bit de modo simb\u00f3lico podemos utilizar: $ ls -l archivo2 -rwxr-xr-x 1 raul raul 0 Feb 2 22:35 archivo2 $ chmod g+s archivo2 $ ls -l archivo2 -rwxr-sr-x 1 raul raul 0 Feb 2 22:35 archivo2 Y de modo absoluto, anteponiendo un dos a los permisos: chmod 2755 archivo2","title":"Bit setgid en un archivo"},{"location":"section/EntLinux/#bit-setgid-en-un-directorio","text":"Si configuramos el bit setgid en un directorio, todos los archivos y subdirectorios reci\u00e9n creados en el directorio heredar\u00e1n el grupo de ese directorio. Sin embargo, los archivos y directorios existentes no aplicar\u00e1n el cambio de grupo. Veamos un ejemplo para aclarar este comportamiento. Primero, preparamos un directorio padre que contiene dos archivos: $ ls -ld padre drwxrwxrwx 2 root raul 4096 Feb 3 00:33 padre/ $ ls -l padre total 2 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 existing_grp_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 existing_grp_invitado2 padre es propiedad del usuario root y del grupo raul. Contiene dos archivos e invitado es due\u00f1o de ambos. A continuaci\u00f3n, establezcamos el bit setgid en padre usando chmod: root# chmod g+s padre root# ls -ld padre drwxrwsrwx 2 root raul 4096 Feb 3 00:33 padre/ Ahora, vamos a crear un nuevo archivo y un subdirectorio bajo el padre con root: root# touch padre/nuevo_root root# mkdir padre/nuevo_dir_root``` Luego, verificaremos los propietarios del grupo de todos los archivos y subdirectorios en padre: root# ls -l padre total 4 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 grp_exist_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00:30 grp_exist_invitado2 drwxr-sr-x 2 root raul 4096 Feb 3 00:54 nuevo_dir_root/ -rw-r--r-- 1 root raul 0 Feb 3 00:54 nuevo_arch_root En la salida anterior, vemos que los dos archivos existentes no han cambiado despu\u00e9s de que establecemos el bit setuid en padre. Sin embargo, el archivo y el subdirectorio reci\u00e9n creados son propiedad de raul en lugar de root , aunque root los cre\u00f3. Esto se debe a que el padre ten\u00eda establecido el bit setgid , y los archivos y directorios reci\u00e9n creados bajo \u00e9l heredaron el grupo del padre.","title":"Bit setgid en un directorio"},{"location":"section/EntLinux/#sticky-bit","text":"La misi\u00f3n del sticky bit es proteger los archivos dentro de un directorio. Si configuramos el sticky bit en un directorio, un archivo en este directorio solo se puede eliminar mediante una de las siguientes opciones: El due\u00f1o del archivo El due\u00f1o del directorio El usuario root En otras palabras, este permiso especial evita que un usuario elimine los archivos de otros usuarios en un directorio p\u00fablico. Un ejemplo t\u00edpico de sticky bit del mundo real es el directorio /tmp: $ ls -ld /tmp drwxrwxrwt 24 root root 980 Feb 3 21:41 /tmp/ Debido a la \"w\" en la secci\u00f3n de permisos \"otros\", sabemos que cualquier usuario puede crear y eliminar cualquier archivo en el directorio /tmp . Pero si leemos la salida de ls anterior con atenci\u00f3n, vemos que el bit de permiso de ejecuci\u00f3n en la secci\u00f3n \"otro\" es una \"t\" min\u00fascula, en lugar de la \"x\" habitual. Esta \"t\" en min\u00fascula indica que el directorio / tmp tiene el bit fijo establecido. Con el sticky bit, cualquier usuario a\u00fan puede crear archivos bajo /tmp. Sin embargo, un usuario solo puede eliminar archivos de su propiedad.","title":"Sticky bit"},{"location":"section/EntLinux/#el-sticky-bit-en-un-directorio","text":"Para establecer el sticky bit en un directorio, a\u00fan podemos usar el comando chmod con el modo + t : chmod +t DIRECTORIO De otra forma, tambi\u00e9n podemos anteponer un \"1\" al modo de un directorio para establecer el sticky bit: chmod 1777 DIRECTORIO Tambi\u00e9n podemos eliminar el sticky bit de un directorio usando -t : chmod -t DIRECTORIO Como de costumbre, veamos un ejemplo para comprender c\u00f3mo el sticky bit puede proteger los archivos de un directorio y c\u00f3mo configurar y eliminar el sticky bit en un directorio. Comencemos por preparar un directorio p\u00fablico llamado p\u00fablico y permitir que todos los usuarios escriban en \u00e9l: $ ls -ld public drwxrwxrwx 2 root root 40 Feb 3 22:22 public/ A continuaci\u00f3n, crearemos algunos archivos en p\u00fablico por diferentes usuarios: $ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo1_invitado -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22:28 archivo_raul Hasta ahora, no hemos colocado el sticky bit en ninguna parte. Veamos si el usuario raul puede eliminar un archivo propiedad de un invitado: raul$ rm archivo1_invitado rm: remove write-protected regular empty archivo 'archivo1_invitado'? y raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22:28 archivo_raul Entonces, sin el sticky bit, podemos eliminar archivos propiedad de otros usuarios. Ahora, configuremos el sticky bit y veamos si hay alg\u00fan cambio: root# chmod +t public root# ls -ld public drwxrwxrwt 2 root root 80 Feb 3 22:33 public/ root# su raul raul$ rm archivo2_invitado rm: remove write-protected regular empty archivo 'archivo2_invitado'? y rm: cannot remove 'archivo2_invitado': Operation not permitted raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22:28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22:28 archivo_raul Despu\u00e9s de configurar el sticky bit, los archivos en p\u00fablico solo pueden ser eliminados por los propietarios del archivo.","title":"El sticky bit en un directorio"},{"location":"section/EntLinux/#principales-comandos-para-manejarse-en-el-terminal","text":"","title":"Principales comandos para manejarse en el terminal"},{"location":"section/EntWin/","text":"Entornos Windows Windows Server 2019 Active Directory y GPOs Actualizaciones del SO Manejo de credenciales Escalada de privilegios EDR","title":"Entornos Windows"},{"location":"section/EntWin/#entornos-windows","text":"","title":"Entornos Windows"},{"location":"section/EntWin/#windows-server-2019","text":"","title":"Windows Server 2019"},{"location":"section/EntWin/#active-directory-y-gpos","text":"","title":"Active Directory y GPOs"},{"location":"section/EntWin/#actualizaciones-del-so","text":"","title":"Actualizaciones del SO"},{"location":"section/EntWin/#manejo-de-credenciales","text":"","title":"Manejo de credenciales"},{"location":"section/EntWin/#escalada-de-privilegios","text":"","title":"Escalada de privilegios"},{"location":"section/EntWin/#edr","text":"","title":"EDR"},{"location":"section/webgrafia/","text":"Archwiki Manuel Mujica Linux.com baeldung.com geeksforgeeks.com","title":"Webgraf\u00eda"}]}