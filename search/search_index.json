{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Los ejercicios y conocimientos contenidos en las pr\u00e1cticas y/o apuntes de todos los m\u00f3dulos tienen exclusivamente prop\u00f3sito formativo, por lo que nunca se deber\u00e1n utilizar con fines maliciosos o delictivos. Ning\u00fan alumno o alumna de este curso, ni profesor o profesora como docentes, ser\u00e1n responsables de los da\u00f1os directos o indirectos que pudieran derivarse del uso inadecuado de las herramientas y mecanismos expuestos.","title":"Home"},{"location":"section/Ej_Linux/","text":"En el primer ejercicio propuesto, vamos a hacer uso de la plataforma Tryhackme . TryHackMe es una plataforma web en la que podremos aprender hacking desde 0, a base de resolver retos con una filosof\u00eda de CTF y gamificaci\u00f3n. Deberemos registrarnos para poder acceder a todas las m\u00e1quinas y salas de la plataforma. Una vez dentro podremos acceder a las 3 salas que vamos a usar. Cada sala en Tryhackme es un reto compuesto de diferentes tareas a completar para alcanzar el 100% del reto. Puesto que estas 3 salas van enlazadas (al finalizar una viene el link de la siguiente) os dejo el link de la primera: Linux Fundamentals part 1 Estas salas con varias tareas cada una son completamente guiadas. Al principio de las mismas hay un v\u00eddeo explicando detalladamente el funcionamiento de las mismas. El v\u00eddeo est\u00e1 en ingl\u00e9s pero se pueden poner los subt\u00edtulos en ingl\u00e9s (bastante buenos) o con traducci\u00f3n autom\u00e1tica (con lo que eso implique...). Deb\u00e9is visionarlo con calma para despu\u00e9s completar las tareas propuestas de la sala. Tarea El objetivo es completar las 3 salas que est\u00e1n formadas principalmente por ejercicios muy b\u00e1sicos de la l\u00ednea de comandos de Linux. En vuestro dashboard os aparecer\u00e1 el progreso de cada una de las salas a medida que vay\u00e1is uniendo\u00f3s a ellas: A modo de demostraci\u00f3n, deb\u00e9is adjuntar una captura de pantalla de vuestro dashboard donde se pueda comprobar que las 3 est\u00e1n completadas al 100% (aparecer\u00e1n en color verde). Algunos v\u00eddeos introductorios a Tryhackme: El segundo ejercicio que os propongo es una suerte de wargame . Iremos a la p\u00e1gina de overthewire que disponer de varios retos, aunque nosotros nos centraremos en Bandit . En la p\u00e1gina inicial a la que os lleva el link, explica el mecanismo del reto. Os deb\u00e9is conectar v\u00eda ssh a la m\u00e1quina bandit.labs.overthewire.org , al puerto 2220 con el usuario bandit0 y el password bandit0 . En Linux pod\u00e9is utilizar directamente la l\u00ednea de comandos, si est\u00e1is bajo un sistema Windows deber\u00e9is utilizar alg\u00fan programa del tipo PuTTY, superPuTTY, MobaXterm o similares . Una vez hecho eso, que es el level0, deb\u00e9is ir al apartado del men\u00fa de la izquierda que os indicar\u00e1 que hacer para pasar de nivel, es decir, a Level 0 -> Level 1 En este men\u00fa nos indica el objetivo a conseguir en este nivel: Es decir, tal y como explica ah\u00ed, el password para ir al siguiente nivel est\u00e1 localizado en el archivo readme que est\u00e1 en el home del usuario. Con este password y usando el usuario bandit1 , podremos conectarnos igual que antes por SSH pero esta vez al nivel1. Os indica adem\u00e1s, a modo de ayuda, algunos de los comandos que pod\u00e9is llegar a necesitar para resolver el nivel. No tienen por qu\u00e9 ser todos, dependiendo de la forma en que lo solucion\u00e9is. El juego sigue este mecanismo para ir pasando de nivel. En ocasiones como pistas os pone los comandos a utilizar tal y como hemos visto y en otras os sugiere lecturas para afrontar el reto: Tarea El objetivo ser\u00eda completar todos los niveles o, en su defecto, llegar lo m\u00e1s lejos posible. Se habr\u00e1 de aportar la contrase\u00f1a de cada nivel as\u00ed como una explicaci\u00f3n de c\u00f3mo se ha obtenido, a modo de prueba.","title":"Ejercicios propuestos Linux"},{"location":"section/Ej_Win/","text":"El ejercicio propuesto para esta parte es muy sencillo: Deb\u00e9is instalar un Windows Server 2019 ( o 2016 en su defecto) y un cliente Windows 10 (Windows 8.1 en su defecto) en sendas m\u00e1quinas virtuales en VirtualBox Deb\u00e9is crearos un usuario con vuestro nombre en el cliente Deb\u00e9is promocionar el Windows Server a controlador de dominio. El nombre de dominio ser\u00e1 \"cibers8a\" Deb\u00e9is a\u00f1adir al usuario del cliente en el dominio Deber\u00e9is configurar una GPO que impida a los usuarios acceder al panel de control Tras forzar la aplicaci\u00f3n de la GPO, deb\u00e9is comprobar en el cliente que vuestro usuario, efectivamente, no tiene permitido el acceso al panel de control","title":"Ejercicios propuestos Windows"},{"location":"section/EntLinux/","text":"En estos primeros pasos veremos algunos conceptos muy b\u00e1sicos que es necesario dominar previo a adquirir cualquier conocimiento relativo a la seguridad de sistemas. Estas nociones b\u00e1sicas nos dar\u00e1n las herramientas principales para desenvolvernos dentro de un sistema y entender los principios de ciberseguridad que se presentar\u00e1n con posterioridad. Estructura de ficheros Un sistema de archivos, llamado com\u00fanmente File System o FS, determina la organizaci\u00f3n de los datos en un soporte de almacenamiento, y por tanto, c\u00f3mo gestiona y organiza el sistema operativo los archivos. Linux es, como todo Unix, un sistema operativo completamente orientado a archivos. Se representa todo (o casi todo) con un archivo, tanto los datos (archivos de datos de cualquier tipo, como una imagen o un programa) como los perif\u00e9ricos (terminales, ratones, teclado, tarjeta sonido, etc.) o incluso los medios de comunicaci\u00f3n (sockets, tuber\u00edas nombradas, etc.). Se puede decir que el sistema de archivos es el coraz\u00f3n de cualquier sistema Unix. Un archivo es una entidad que almacena datos y programas. Se compone de contenido y metadatos (tama\u00f1o del archivo, propietario, fecha de creaci\u00f3n, permisos). Los archivos est\u00e1n organizados en directorios. Un directorio es un archivo que almacena otros archivos. Los diferentes tipos de archivos incluyen: Archivos regulares que almacenan datos y programas. Directorios que contienen otros archivos. Archivos especiales que se utilizan para entrada y salida. Todo en Linux es un archivo , por lo que saber c\u00f3mo manipularlos es muy importante. As\u00ed pues, en la secci\u00f3n correspondiente, veremos las operaciones b\u00e1sicas con archivos mediante el terminal. La estructura de los directorios de Linux, as\u00ed como su contenido y funciones, viene definida en el denominado Filesystem Hierarchy Standard o FHS por sus siglas en ingl\u00e9s, que en otras palabras viene a ser el est\u00e1ndar de jerarqu\u00eda para los sistemas de archivos en sistemas Linux y otros derivados de UNIX. Como pod\u00e9is ver en la siguiente imagen, todo el \u00e1rbol de parte de una ra\u00edz com\u00fan denominada root y que se simboliza por una barra inclinada. A\u00fan as\u00ed, esto no significa que varios de ellos no puedan estar en particiones separadas del resto. De hecho, en muchas distros GNU/Linux es una pr\u00e1ctica muy com\u00fan el hecho ubicar ciertos directorios en particiones separadas del resto. La FHS distingue entre lo que ser\u00edan directorios est\u00e1ticos, que son aquellos que contienen binarios, bibliotecas, documentaci\u00f3n, etc., de los din\u00e1micos, que son aquellos que requieren de acciones m\u00e1s a menudo, tales como copias de seguridad, etc. Tambi\u00e9n podemos diferencias claramente lo que son los directorios compartibles, que significa que contienen ficheros que pueden utilizarse desde otros dispositivos, de los no compartibles, que solo pueden utilizarse desde el dispositivo en el que se encuentran. Directorio ra\u00edz o \"/\" Toda la estructura de directorios en los sistemas basados en UNIX parte de un directorio ra\u00edz tambi\u00e9n llamado directorio root y que se simboliza por una barra inclinada o /. De este directorio, es desde donde nacen todo el resto de directorios, independientemente que est\u00e9n almacenados f\u00edsicamente en discos o unidades separadas. Cualquier direcci\u00f3n de archivo o carpeta en Linux empieza por el directorio ra\u00edz o /, seguido de todos los directorios y subdirectorios que que lo contienen, separados cada uno de ellos por /. A continuaci\u00f3n conocer\u00e1s con m\u00e1s en detalle a todos los directorios principales que parten del directorio ra\u00edz, junto con sus subdirectorios m\u00e1s importantes y los ficheros que suelen contener. Directorio/s bin, sbin El directorio /bin es un directorio est\u00e1tico y es donde se almacenan todos los binarios necesarios para garantizar las funciones b\u00e1sicas a nivel de usuario. Solo almacena los ejecutables de usuario, ya que los binarios necesarios para tareas administrativas gestionadas por el usuario root o superusuario del sistema se encuentran en el directorio /sbin. Incluye tambi\u00e9n los binarios que permiten la ejecuci\u00f3n de varias utilidades est\u00e1ndar de la terminal de Linux, concretamente cat, cd, cp, echo, grep, gzip, kill, ls, mv, rm, ping, su, ps, tar y vi. El directorio /sbin hace lo mismo pero para los binarios relativos tareas propias del sistema operativo, y que solamente pueden ser gestionadas por el usuario root, tales como el arranque, tareas de restauraci\u00f3n, reparaci\u00f3n, etc. Directorio /boot Es un directorio est\u00e1tico y contiene los archivos necesarios para arrancar el sistema. Los archivos del cargador de arranque GRUB y los kernels de Linux se almacenan aqu\u00ed, por ejemplo. Sin embargo, los archivos de configuraci\u00f3n del cargador de arranque no se encuentran aqu\u00ed, est\u00e1n en /etc con los otros archivos de configuraci\u00f3n. A la hora de instalar el sistema es importante prever bien el espacio que se le vaya a dar a la partici\u00f3n, ya que a la larga, con la acumulaci\u00f3n de diferentes actualizaciones del Kernel, es com\u00fan que se quede sin espacio. Si esto sucede, se pueden tener problemas a la hora de instalar futuras actualizaciones del n\u00facleo, y ser\u00e1 necesario hacer limpieza de versiones antiguas del kernel. Directorio /dev Este directorio incluye todos los dispositivos de almacenamiento, en forma de archivos especiales, conectados al sistema. Es decir, cualquier disco duro, partici\u00f3n, memoria USB, o CDROM conectado al sistema y que el sistema pueda entender como un volumen l\u00f3gico de almacenamiento. Siendo esto as\u00ed, ver\u00e9is que la ruta en la que se encuentra cualquier volumen (partici\u00f3n o dispositivo externo) conectado al sistema siempre empieza por /dev. Este es el directorio que contiene, por decirlo de alg\u00fan modo, la informaci\u00f3n de cada uno de los vol\u00famenes, a diferencia del directorio /media , que veremos m\u00e1s adelante, que lo que contiene son solo los puntos de montaje, pero no la informaci\u00f3n real de estos vol\u00famenes. Para ver esto en la pr\u00e1ctica, si abres una ventana de terminal y ejecutas el comando sudo fdisk -l , ver\u00e1s la estructura de particiones de tu sistema. En una instalaci\u00f3n t\u00edpica de cualquier distro GNU/Linux suele ser la siguiente: /dev/sda1 - Partici\u00f3n principal /dev/sda2 - Partici\u00f3n extendida /dev/sda5 - Partici\u00f3n Swap Estos no son archivos reales como los conocemos, pero aparecen como archivos; por ejemplo, /dev/sda representa la primera unidad SATA del sistema. Eso en cuanto a particiones. Si se trata de un dispositivo externo, el volumen estar\u00e1 igualmente dentro de /dev, pero en este caso var\u00eda el nombre que el sistema le asigna a dicho volumen. Generalmente la estructura suele ser la siguiente (ejecutando nuevamente el comando sudo fdisk -l con un dispositivo externo conectado puede comprobarse). /dev/sdb1 /dev/sdb2 /dev/sdb3 ... Este directorio tambi\u00e9n contiene pseudodispositivos, que son dispositivos virtuales que en realidad no se corresponden con el hardware. Por ejemplo, /dev/random produce n\u00fameros aleatorios. Otro ejemplo ser\u00eda el de /dev/null , un dispositivo especial que no produce salida y descarta autom\u00e1ticamente todas las entradas; cuando canaliza la salida de un comando a /dev/null , la descarta. Directorio /etc El directorio /etc contiene archivos de configuraci\u00f3n, que generalmente se pueden editar a mano en un editor de texto. Se debe tener en cuenta que el directorio /etc contiene archivos de configuraci\u00f3n de todo el sistema, adem\u00e1s de las aplicaciones y programas instaladas posteriormente; los archivos de configuraci\u00f3n espec\u00edficos del usuario se encuentran en el directorio de inicio de cada usuario. Es un directorio que deber\u00eda contener \u00fanicamente ficheros de configuraci\u00f3n, y no deber\u00eda contener binarios. Directorio lib Incluye las bibliotecas esenciales que son necesarias para que se puedan ejecutar correctamente todos los binarios que se encuentran en los directorios /bin y /sbin , as\u00ed como los m\u00f3dulos del propio kernel. En los sistemas operativos de 64 bits, adem\u00e1s de /lib existe otro directorio denominado /lib64 , referida a las bibliotecas para aplicaciones de 64 bits. Directorio media Representa el punto de montaje de todos los vol\u00famenes l\u00f3gicos que se montan temporalmente. Es decir, El directorio /media contiene subdirectorios donde se montan los dispositivos de medios extra\u00edbles insertados en el ordenador. En la mayor\u00eda de distribuciones GNU/Linux, desde hace ya alg\u00fan tiempo, cada vez que se monta una unidad externa, partici\u00f3n, etc., esta se monta dentro del directorio /media y a su vez dentro de un directorio especifico dependiendo del usuario del sistema que monta el volumen. De este modo, si en un sistema hay varios usuarios, pongamos User1 y User2, los puntos de montaje de los vol\u00famenes que montan cada uno de ellos se mostraran en directorios separados tal como as\u00ed: /media/User1 /media/User2 Directorio opt El directorio /opt contiene subdirectorios para paquetes de software opcionales. Es com\u00fanmente utilizado por software propietario que no obedece a la jerarqu\u00eda del sistema de archivos est\u00e1ndar; por ejemplo, un programa propietario puede volcar sus archivos en /opt/NombreAplicacion cuando se instala. Antiguamente se sol\u00eda utilizar el directorio mnt para estas funciones, pero actualmente, la mayor\u00eda de distribuciones hacen uso de media. Directorio proc Este directorio contiene informaci\u00f3n de los procesos y aplicaciones que se est\u00e1n ejecutando en un momento determinado en el sistema, pero realmente no guarda nada como tal, ya que lo que almacena son archivos virtuales, por lo que el contenido de este directorio es nulo. Directorio /root El directorio /root es el directorio de inicio del usuario root. En lugar de estar ubicado en /home/root , est\u00e1 ubicado en /root . Es distinto de / , que es el directorio ra\u00edz del sistema. Directorio tmp Las aplicaciones almacenan archivos temporales en el directorio /tmp . Estos archivos generalmente se eliminan cada vez que se reinicia su sistema y pueden ser eliminados en cualquier momento por utilidades como tmpwatch. Las aplicaciones programadas para almacenar archivos en este directorio deben asumir que solo ser\u00e1n recuperables en la sesi\u00f3n actual. En este sentido, hay otro subdirectorio, /var/tmp , dispuesto igualmente para el almacenamiento de archivos temporales, pero cuyo contenido no se borra de forma autom\u00e1tica tras el reinicio del sistema. Directorio usr El directorio /usr contiene aplicaciones y archivos utilizados por los usuarios, a diferencia de las aplicaciones y archivos utilizados por el sistema, incluyendo todo el software instalado a trav\u00e9s de los gestores de paquetes de cada distribuci\u00f3n. Por ejemplo, las aplicaciones no esenciales se encuentran dentro del directorio /usr/bin en lugar del directorio /bin y los binarios de administraci\u00f3n del sistema no esenciales se encuentran en el directorio /usr/sbin en lugar del directorio /sbin . Las bibliotecas para cada uno se encuentran dentro del directorio /usr/lib . El directorio /usr tambi\u00e9n contiene otros directorios; por ejemplo, los archivos independientes de la arquitectura, como los gr\u00e1ficos, se encuentran en /usr/share : /usr/bin /usr/include /usr/lib /usr/local /usr/sbin /usr/share /usr/src El directorio /usr/local es donde se instalan las aplicaciones compiladas localmente de forma predeterminada; esto evita que arruinen el resto del sistema Directorio var Este directorio contiene varios archivos con informaci\u00f3n del sistema, como archivos de logs, emails de los usuarios del sistema, bases de datos, informaci\u00f3n almacenada en la cach\u00e9 o informaci\u00f3n relativa a los paquetes de aplicaciones almacenados en /opt . En cierto modo se podr\u00eda decir que act\u00faa a modo de registro del sistema. Podr\u00eda decirse que el directorio /var es la contraparte \"escriturable\" del directorio /usr , que debe ser de solo lectura en el funcionamiento normal. Los archivos de registro y todo lo dem\u00e1s que normalmente se escribir\u00eda en /usr durante el funcionamiento normal se escriben en el directorio /var . Directorio home El directorio /home contiene una carpeta de inicio para cada usuario. Por ejemplo, si el nombre de usuario es raul, habr\u00e1 una carpeta de inicio ubicada en /home/raul . Esta carpeta de inicio contiene los archivos de datos del usuario y los archivos de configuraci\u00f3n espec\u00edficos del usuario (configuraciones de programas, por ejemplo). Cada usuario solo tiene acceso de escritura \u00fanicamente a su propia carpeta de inicio y debe convertirse en root para poder tener privilegios que le permitan modificar otros archivos en el sistema. Para visualizar los ficheros ocultos dentro del directorio individual de cada usuario, se puede usar la combinaci\u00f3n de comandos CTRL + H en modo gr\u00e1fico. Todos los archivos y carpetas ocultas en Linux empiezan por un punto, seguido del nombre. En muchas distribuciones es una pr\u00e1ctica recomendada el hecho de ubicar el directorio /home es una partici\u00f3n separada del resto, por tal de facilitar que, en caso de reinstalar el sistema operativo, puedas mantener intacta la partici\u00f3n de la /home , y de este modo mantener todos los archivos personales. Usuarios y grupos Un usuario es cualquiera que use un ordenador. En este caso, estamos describiendo los nombres que representan a esos usuarios. Puede ser Pol o Mart\u00ed, y pueden usar los nombres superc0der o Pirate en lugar de su nombre real. Lo \u00fanico que importa es que la computadora tenga un nombre para cada cuenta que cree, y es este nombre por el que una persona obtiene acceso para usar la computadora. Algunos servicios del sistema tambi\u00e9n se ejecutan utilizando cuentas de usuario restringidas o privilegiadas. La administraci\u00f3n de los usuarios se realiza con fines de seguridad al limitar el acceso de ciertas maneras espec\u00edficas. El superusuario (root) tiene acceso completo al sistema operativo y su configuraci\u00f3n; est\u00e1 destinado solo para uso administrativo. Los usuarios sin privilegios pueden usar los programas su y sudo para la escalada de privilegios controlada. Cualquier persona puede tener m\u00e1s de una cuenta, siempre que utilicen un nombre diferente para cada una de ellas. Adem\u00e1s, hay algunos nombres reservados que no se pueden usar, como \u00abroot\u00bb. Los usuarios pueden aglutinarse en un \u00abgrupo\u00bb y, del mismo modo, pueden a\u00f1adirse a un grupo existente para utilizar el acceso privilegiado que dicho grupo concede. Los grupos de usuarios juegan un papel esencial en los sistemas Linux. Gracias a ellos tenemos una manera muy f\u00e1cil de seleccionar grupos de usuarios a los que se les permite compartir archivos entre ellos. Tambi\u00e9n proporcionan a los administradores de sistemas una manera m\u00e1s efectiva y sencilla de gestionar los privilegios de los usuarios puesto que permiten asignar privilegios a grupos completos en lugar de a usuarios individuales. Permisos Aunque hay multitud de caracter\u00edsticas de seguridad integradas en los sistemas basados \u200b\u200ben Linux, puede existir una vulnerabilidad potencial muy importante cuando se otorga el acceso al sistema a los usuarios. Pueden aparecer problemas cuando no se han asignado los permisos adecuados a los archivos y directorios. Grupos de permisos Cada archivo y directorio tiene tres grupos de permisos basados \u200b\u200ben usuarios: Propietario: los permisos de propietario se aplican solo al propietario del archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Grupo: los permisos de grupo se aplican solo al grupo que se ha asignado al archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Todos los usuarios: los permisos de todos los usuarios se aplican a todos los dem\u00e1s usuarios del sistema; este es el grupo de permisos que m\u00e1s desea ver. Tipos de permisos Cada archivo o directorio tiene tres tipos de permisos b\u00e1sicos: Lectura (read/r): el permiso de lectura se refiere a la capacidad de un usuario para leer el contenido del archivo. El permiso de lectura en un directorio permite listar su contenido. Escritura (write/w): los permisos de escritura se refieren a la capacidad de un usuario para escribir o modificar un archivo. En un directorio permite crear, eliminar o modificar el nombre de un archivo. En un hipot\u00e9tico caso donde tuvi\u00e9ramos permiso de escritura en un archivo pero no en el directorio en el que est\u00e1 ubicado, podr\u00edamos modificar el contenido del archivo pero no su nombre, ni moverlo de sitio, ni eliminarlo del directorio. Ejecuci\u00f3n (execution/x): el permiso de ejecuci\u00f3n afecta la capacidad de un usuario para ejecutar un archivo o ver el contenido de un directorio. Tip Podemos inspeccionar con detalle los permisos de arhivos y directorios con el comando: ls -l \u00bfC\u00f3mo se cambian los permisos en Linux? Para cambiar los permisos de archivos y directorios en GNU/Linux, disponemos de 3 comandos principales: chmod: cambiar permisos del archivo o directorio: chmod [ permisos ][ archivo/directorio ][ opciones ] chown: cambiar el propietario del archivo o directorio: chown [ nuevo usuario propietario ][ archivo/directorio ][ opciones ] chgrp: cambiar el grupo del archivo o directorio: chgrp [ nuevo grupo ][ archivo/directorio ][ opciones ] Existen dos formas de cambiar los permisos de archivos y directorios en Linux: Modo simb\u00f3lico: con notaci\u00f3n basada en caracteres Modo absoluto: con notaci\u00f3n num\u00e9rica, seg\u00fan el sistema octal o en base 8 , cuyos valores de forma resumida puedne verse en la imagen a continuaci\u00f3n: As\u00ed pues, una tabla resumen en cu\u00e1nto a los permisos vistos, ser\u00eda la siguiente: Valor Permisos Descripci\u00f3n 0 --- Sin permisos 1 --x Ejecuci\u00f3n 2 -w- Lectura 3 -wx Lectura + ejecuci\u00f3n 4 r-- Lectura 5 r-x Lectura + ejecuci\u00f3n 6 rw- Lectura + escritura 7 rwx Lectura + escritura + ejecuci\u00f3n Los permisos utilizando la notaci\u00f3n num\u00e9rica en sistema octal, se asignan en tuplas de 3 (usuario/grupo/otros) y no es posible asignar s\u00f3lo para uno o dos de los elementos de la tupla. Algunos ejemplos de permisos en modo absoluto son: Notaci\u00f3n Significado rw------- (600) Permisos de lectura y escritura s\u00f3lo para el propietario rw-r--r-- (644) Permisos de lectura y escritura s\u00f3lo para el propietario y s\u00f3lo de lectura para el grupo y resto de usuarios rwxr-xr-x (755) Permisos de lectura, escritura y ejecuci\u00f3n para el usuario y de lectura y ejecuci\u00f3n para el grupo y resto de usuarios rwxrwxrwx (777) Usuario, grupo y resto de usuarios tienen todos los permisos sobre el fichero o directorio (\u00a1Cuidado!) rw-rw-rw- (666) Usuario, grupo y resto de usuarios pueden leer y escribir sobre el fichero o directorio(\u00a1cuidado!) Como ya hemos dicho es el comando chmod el utilizado en el terminal para cambiar los permisos de los usuarios. Puede usarse tanto con el modo absoluto como con el simb\u00f3lico. Un ejemplo para el formato absoluto ser\u00eda: chmod 600 archivo/directorio Y para el formato con caracteres chmod ugo+rw archivo/directorio Donde, en este \u00faltimo caso, los permisos rwx (lectura/escritura/ejecuci\u00f3n) pueden asignarse a: u - propietario g - grupo o - otros a - todos los usuarios Si utilizamos el operador + estaremos agregando permisos, si usamos el - los eliminaremos: chmod a-rw archivo1 chmod u+rwx archivo2 Ejemplos pr\u00e1cticos del uso de chmod para cambiar permisos de un archivo. Podemos utilizar tanto la forma absoluta, como la simb\u00f3lica: Modo absoluto Modo simb\u00f3lico Resultado chmod 700 archivo.gpg chmod u+rwx -rwx------ chmod 555 chmod ugo+rx -r-xr-xr-x chmod 666 -chmod ugo+rw rw-rw-rw- Permisos avanzados En GNU/Linux, adem\u00e1s de los 3 que hemos visto anteriormente, todav\u00eda existen otros tres permisos especiales adicionales que veremos a continuaci\u00f3n. Bit setuid En Linux, de forma predeterminada, cuando un usuario ejecuta un archivo, el archivo se inicia con los privilegios del usuario que lo ejecuta. Sin embargo, este comportamiento se puede cambiar si establecemos permisos especiales en archivos ejecutables. Setuid significa \"establecer ID de usuario\". Si configuramos el bit setuid en un archivo ejecutable, el archivo siempre se ejecuta con los privilegios del propietario del archivo, sin importar qui\u00e9n lo inicie. El bit setuid solo tiene sentido si est\u00e1 configurado en archivos ejecutables. No hay ning\u00fan significado pr\u00e1ctico si configuramos el bit setuid en un archivo o directorio no ejecutable. El comando passwd es un ejemplo con este bit especial aplicado: $ ls -l /bin/passwd -rwsr-xr-x 1 root root 63624 Dec 15 21 :06 /bin/passwd Observamos que el permiso de ejecuci\u00f3n para el propietario es una \"s\" min\u00fascula en lugar de la \"x\" habitual. Esta \"s\" indica que el archivo tiene el bit setuid establecido. El comando passwd siempre se ejecutar\u00e1 con privilegios de root sin importar qui\u00e9n lo inicie porque el propietario del archivo es root. Como ya sabemos, podemos usar el comando chmod para establecer el bit setuid en un archivo: chmod u+x archivo S\u00f3lo el propietario el archivo o el usuario o el usuario root puede establecer el bit setuid Un ejemplo pr\u00e1ctico de c\u00f3mo configurar este bit setuid en un archivo, de forma simb\u00f3lica: $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo $ chmod u+s archivo $ ls -l archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo En el modo absoluto, anteponemos un 4 a los permisos para indicar este bit: $ chmod 4755 archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo Y para quitar este bit, en ambos modos: $ chmod u-s archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo y $ chmod 0755 archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo Riesgo de seguridad El bit setuid podr\u00eda ser bastante \u00fatil en varias aplicaciones. Sin embargo, debemos tener cuidado al establecer esos permisos especiales, ya que pueden crear problemas de seguridad. Por ejemplo, un usuario normal puede obtener privilegios de superusuario ejecutando un programa que establece el UID como root y realizar una escalada de privilegios. Bit setgid Bit setgid en un archivo setgid es la abreviatura de \"set group id\". Si configuramos el bit setgid en un archivo ejecutable, no importa qui\u00e9n inicie el archivo, se ejecuta con los privilegios del grupo propietario. El comando de localizaci\u00f3n es un ejemplo de un archivo con el conjunto de bits setgid : $ ls -l /usr/bin/locate -rwxr-sr-x 1 root locate 43048 Nov 13 18 :09 /usr/bin/locate Similar al bit setuid , notamos una \"s\" min\u00fascula en la salida de ls , excepto que est\u00e1 en la secci\u00f3n de grupo en lugar de en la secci\u00f3n de propietario. Para establecer este bit de modo simb\u00f3lico podemos utilizar: $ ls -l archivo2 -rwxr-xr-x 1 raul raul 0 Feb 2 22 :35 archivo2 $ chmod g+s archivo2 $ ls -l archivo2 -rwxr-sr-x 1 raul raul 0 Feb 2 22 :35 archivo2 Y de modo absoluto, anteponiendo un dos a los permisos: chmod 2755 archivo2 Bit setgid en un directorio Si configuramos el bit setgid en un directorio, todos los archivos y subdirectorios reci\u00e9n creados en el directorio heredar\u00e1n el grupo de ese directorio. Sin embargo, los archivos y directorios existentes no aplicar\u00e1n el cambio de grupo. Veamos un ejemplo para aclarar este comportamiento. Primero, preparamos un directorio padre que contiene dos archivos: $ ls -ld padre drwxrwxrwx 2 root raul 4096 Feb 3 00 :33 padre/ $ ls -l padre total 2 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 existing_grp_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 existing_grp_invitado2 padre es propiedad del usuario root y del grupo raul. Contiene dos archivos e invitado es due\u00f1o de ambos. A continuaci\u00f3n, establezcamos el bit setgid en padre usando chmod: root# chmod g+s padre root# ls -ld padre drwxrwsrwx 2 root raul 4096 Feb 3 00 :33 padre/ Ahora, vamos a crear un nuevo archivo y un subdirectorio bajo el padre con root: root# touch padre/nuevo_root root# mkdir padre/nuevo_dir_root ``` Luego, verificaremos los propietarios del grupo de todos los archivos y subdirectorios en padre: root# ls -l padre total 4 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 grp_exist_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 grp_exist_invitado2 drwxr-sr-x 2 root raul 4096 Feb 3 00 :54 nuevo_dir_root/ -rw-r--r-- 1 root raul 0 Feb 3 00 :54 nuevo_arch_root En la salida anterior, vemos que los dos archivos existentes no han cambiado despu\u00e9s de que establecemos el bit setuid en padre. Sin embargo, el archivo y el subdirectorio reci\u00e9n creados son propiedad de raul en lugar de root , aunque root los cre\u00f3. Esto se debe a que el padre ten\u00eda establecido el bit setgid , y los archivos y directorios reci\u00e9n creados bajo \u00e9l heredaron el grupo del padre. Sticky bit La misi\u00f3n del sticky bit es proteger los archivos dentro de un directorio. Si configuramos el sticky bit en un directorio, un archivo en este directorio solo se puede eliminar mediante una de las siguientes opciones: El due\u00f1o del archivo El due\u00f1o del directorio El usuario root En otras palabras, este permiso especial evita que un usuario elimine los archivos de otros usuarios en un directorio p\u00fablico. Un ejemplo t\u00edpico de sticky bit del mundo real es el directorio /tmp: $ ls -ld /tmp drwxrwxrwt 24 root root 980 Feb 3 21 :41 /tmp/ Debido a la \"w\" en la secci\u00f3n de permisos \"otros\", sabemos que cualquier usuario puede crear y eliminar cualquier archivo en el directorio /tmp . Pero si leemos la salida de ls anterior con atenci\u00f3n, vemos que el bit de permiso de ejecuci\u00f3n en la secci\u00f3n \"otro\" es una \"t\" min\u00fascula, en lugar de la \"x\" habitual. Esta \"t\" en min\u00fascula indica que el directorio / tmp tiene el bit fijo establecido. Con el sticky bit, cualquier usuario a\u00fan puede crear archivos bajo /tmp. Sin embargo, un usuario solo puede eliminar archivos de su propiedad. El sticky bit en un directorio Para establecer el sticky bit en un directorio, a\u00fan podemos usar el comando chmod con el modo + t : chmod +t DIRECTORIO De otra forma, tambi\u00e9n podemos anteponer un \"1\" al modo de un directorio para establecer el sticky bit: chmod 1777 DIRECTORIO Tambi\u00e9n podemos eliminar el sticky bit de un directorio usando -t : chmod -t DIRECTORIO Como de costumbre, veamos un ejemplo para comprender c\u00f3mo el sticky bit puede proteger los archivos de un directorio y c\u00f3mo configurar y eliminar el sticky bit en un directorio. Comencemos por preparar un directorio p\u00fablico llamado p\u00fablico y permitir que todos los usuarios escriban en \u00e9l: $ ls -ld public drwxrwxrwx 2 root root 40 Feb 3 22 :22 public/ A continuaci\u00f3n, crearemos algunos archivos en p\u00fablico por diferentes usuarios: $ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo1_invitado -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22 :28 archivo_raul Hasta ahora, no hemos colocado el sticky bit en ninguna parte. Veamos si el usuario raul puede eliminar un archivo propiedad de un invitado: raul$ rm archivo1_invitado rm: remove write-protected regular empty archivo 'archivo1_invitado' ? y raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22 :28 archivo_raul Entonces, sin el sticky bit, podemos eliminar archivos propiedad de otros usuarios. Ahora, configuremos el sticky bit y veamos si hay alg\u00fan cambio: root# chmod +t public root# ls -ld public drwxrwxrwt 2 root root 80 Feb 3 22 :33 public/ root# su raul raul$ rm archivo2_invitado rm: remove write-protected regular empty archivo 'archivo2_invitado' ? y rm: cannot remove 'archivo2_invitado' : Operation not permitted raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22 :28 archivo_raul Despu\u00e9s de configurar el sticky bit, los archivos en p\u00fablico solo pueden ser eliminados por los propietarios del archivo. Contrase\u00f1as en Linux En este apartado se describe c\u00f3mo se implementan las contrase\u00f1as dentro del sistema operativo Unix tanto para sistemas administrados localmente como basados \u200b\u200ben red. El archivo /etc/passwd Tradicionalmente, Unix usa el archivo /etc/passwd para realizar un seguimiento de cada usuario en el sistema. El archivo / etc / passwd contiene el nombre de usuario, el nombre real, la informaci\u00f3n de identificaci\u00f3n y la informaci\u00f3n b\u00e1sica de la cuenta de cada usuario. Cada l\u00ednea del archivo contiene un registro de base de datos; los campos de registro est\u00e1n separados por dos puntos (:). Puedes usar el gato comando para mostrar el archivo / etc / passwd de su sistema. Aqu\u00ed hay algunas l\u00edneas de muestra de un archivo t\u00edpico: root:x:0:1:System Operator:/:/bin/ksh daemon:x:1:1::/tmp: uucp:x:4:4::/var/spool/uucppublic:/usr/lib/uucp/uucico rocio:x:181:100:Rocio Cordoba:/home/rachel:/bin/ksh arturo:x.:182:100:Arturo Soria:/home/arlin:/bin/csh Las primeras tres cuentas, root , daemon y uucp , son cuentas del sistema, mientras que rachel y arlin son cuentas para usuarios individuales. Los campos individuales del archivo / etc / passwd tienen significados bastante sencillos. La Tabla 4-1 explica una l\u00ednea de muestra del archivo que se muestra arriba. Alguno de los campos m\u00e1s importantes del archivo /etc/passwd, son: Campo Contenido Raquel Nombre de usuario. x Lugar de espera para la \"contrase\u00f1a cifrada\" del usuario. Tradicionalmente, este campo almacenaba la contrase\u00f1a cifrada del usuario. Los sistemas Unix modernos almacenan contrase\u00f1as cifradas en un archivo separado (el archivo de contrase\u00f1as ocultas ) al que solo pueden acceder los usuarios privilegiados. 181 N\u00famero de identificaci\u00f3n de usuario (UID) del usuario. 100 N\u00famero de identificaci\u00f3n de grupo del usuario (GID). Rocio Cordoba Nombre completo del usuario /home/rocio Directorio de inicio del usuario. /bin/ksh Shell del usuario. Las contrase\u00f1as se almacenaban tradicionalmente en el archivo /etc/passwd en un formato cifrado. Sin embargo, debido a los avances en la velocidad del procesador, las contrase\u00f1as cifradas ahora se almacenan casi universalmente en un archivo independiente, llamado /etc/shadow , que se describe m\u00e1s adelante. El sistema de contrase\u00f1as cifradas en Unix/Linux Cuando Unix/Linux solicita su contrase\u00f1a, necesita alguna forma de determinar que la contrase\u00f1a es correcta. Muchos de los primeros sistemas inform\u00e1ticos almacenaban las contrase\u00f1as de todas sus cuentas en texto plano en un archivo. En circunstancias normales, el sistema proteg\u00eda las contrase\u00f1as de modo que solo los usuarios privilegiados y las utilidades del sistema operativo pudieran acceder a ellas. Sin embargo, bien por accidente, bien por un error de programaci\u00f3n o por un acto deliberado, un usuario no privilegiado podr\u00eda acceder al contenido de este archivo. Para muestra un bot\u00f3n: Una de las situaciones m\u00e1s memorables ocurri\u00f3 a principios de la d\u00e9cada de 1960 cuando un administrador del sistema en el sistema CTSS del MIT estaba editando el archivo de contrase\u00f1as y otro administrador del sistema estaba editando el mensaje diario que se imprime en el terminal de todos al iniciar sesi\u00f3n. Debido a un error de dise\u00f1o del software, los archivos temporales del editor de los dos usuarios se intercambiaron y, por lo tanto, durante un tiempo, el archivo de contrase\u00f1a se imprimi\u00f3 en cada terminal cuando se iniciaba sesi\u00f3n. El peligro real que planteaban estos sistemas es que los usuarios pueden hacer copias del archivo de contrase\u00f1as y robarlas sin el conocimiento del administrador del sistema. Unix/Linux evitan este problema al no mantener las contrase\u00f1as reales en ninguna parte del sistema. En su lugar, Unix/Linux almacenan un valor que es generado mediante el uso de la contrase\u00f1a para cifrar un bloque de bits con una funci\u00f3n unidireccional llamada crypt(); el resultado del c\u00e1lculo se almacenaba tradicionalmente en /etc/passwd. Cuando se intenta iniciar sesi\u00f3n, el programa /bin/login no descifra la contrase\u00f1a almacenada. En su lugar, /bin/login toma la contrase\u00f1a que ingres\u00f3, la usa para transformar otro bloque de ceros y compara el bloque reci\u00e9n transformado con el bloque almacenado en el archivo /etc/passwd. Si los dos resultados cirfrados coinciden, el sistema lo deja entrar. La funci\u00f3n de cifrado tradicional crypt() El algoritmo que usa crypt() tradicionalmente se basa en el Est\u00e1ndar de cifrado de datos (DES) del Instituto Nacional de Est\u00e1ndares y Tecnolog\u00eda (NIST). En funcionamiento normal, DES utiliza una clave de 56 bits (8 caracteres ASCII de 7 bits, por ejemplo) para cifrar bloques de texto original o texto sin cifrar, que resultaban tener 64 bits de longitud. Los bloques de 64 bits resultantes de texto cifrado o texto cifrado no se pueden descifrar f\u00e1cilmente al texto sin formato original sin conocer la clave original de 56 bits. Actualmente este algoritmo ha sido sustituido por unos mucho m\u00e1s seguros y robustos. Ech\u00e1ndole \"salt\" A medida que los ordenadores aumentaban de potencia y los algoritmos de cifrado fueron empezando a considerarse inseguros por ello, se inventaron nuevas formas de fortificarlos. Una de ellas fue el elemento conocido como \"salt\". En criptograf\u00eda, la sal (en ingl\u00e9s, salt) comprende bits aleatorios que se usan como una de las entradas en una funci\u00f3n derivadora de claves. La otra entrada es habitualmente una contrase\u00f1a. La salida de la funci\u00f3n derivadora de claves se almacena como la versi\u00f3n cifrada de la contrase\u00f1a. En definitiva, el salt es una cadena de caracteres aleatorios que se concatenan con la contrase\u00f1a antes de cifrarla para dificultad en gran medida su descifrado por un atacante. Los datos con sal complican los ataques de diccionario que cifran cada una de las entradas del mismo: cada bit de sal duplica la cantidad de almacenamiento y computaci\u00f3n requeridas. Para mayor seguridad, el valor de sal se guarda en secreto, separado de la base de datos de contrase\u00f1as. Esto aporta una gran ventaja cuando la base de datos es robada, pero la sal no. El beneficio aportado por usar una contrase\u00f1a con sal es que un ataque simple de diccionario contra los valores cifrados es impracticable si la sal es lo suficientemente larga. As\u00ed el formato del contenido del archivo /etc/shadow es: El campo a la derecha del nombre de usuario indica qu\u00e9 algoritmo se ha utilizado para cifrar la contrase\u00f1a junto con el salt del tercer campo. Por curiosidad, algunos de estos algorimos son: Valor Algoritmo $1$ MD5 $2a$ Blowfish $2y$ Blowfish $5$ SHA-256 $6$ SHA-512 Los signos del d\u00f3lar delimitan estos dos campos. Principales comandos para manejarse en el terminal Crear archivos y directorios A modo de tutorial, puede ser interesante seguir los comandos que aqu\u00ed se muestran. Para ello, en primer lugar vamos a crear un subdirectorio dentro del directorio /tmp y nos ubicaremos dentro de ese subdirectorio: mkdir /tmp/tutorial cd /tmp/tutorial El comando mkdir es una abreviatura de \"make directory\" y se utiliza para crear nuevos directorios vac\u00edos. Permite incluso crear varios directorios en un s\u00f3lo comando utilizando el n\u00famero de par\u00e1metros o argumentos adecuado: mkdir dir1 dir2 dir3 Si quisi\u00e9ramos listar los directorios creados, podr\u00edamos utilizar el comando para ello: ls Podr\u00edamos incluso darle una vuleta de tuerca al comando. Ya que los directorios que crea est\u00e1n vac\u00edos, pero si quisi\u00e9ramos crear una carpeta con subdirectorios en su interior utilizando un \u00fanico comando, har\u00edamos: mkdir -p dir4/dir5/dir6 ls El \"-p\" es lo que se conoce como un switch , que no son m\u00e1s que distintas opciones para modificar el comportamiento de un comando. Y podr\u00edamos movernos por los subdirectorios para comprobar que, efectivamente, se han creado: cd dir4 ls cd dir5 ls cd ../.. Ahora que ya sabemos c\u00f3mo crear varios directorios simplemente pas\u00e1ndolos como argumentos separados al mkdircomando. Pero supongamos que queremos crear un directorio con un espacio en el nombre. Vamos a intentarlo: mkdir otro directorio ls Pod\u00e9is intentar escribir esto en el terminal o, si s\u00f3is un poco suspicaces, os habr\u00e9is dado cuenta de lo que pasar\u00e1. Exactamente, se crearan dos directorios distintos. Si queremos trabajar con espacios en nombres de archivos o directorios, necesitamos \"escaparlos\" . \u00c9ste es un termino inform\u00e1tico que hace referencia a c\u00f3digos especiales para decirle a la m\u00e1quina que determinados caracteres y s\u00edmbolos los trate de forma diferente a lo normal. Como ejemplo: mkdir \"carpeta 1\" mkdir 'carpeta 2' mkdir carpeta \\ 3 mkdir \"carpeta 4\" \"carpeta 5\" mkdir -p \"carpeta 6\" / \"carpeta 7\" ls Todos estos comandos crear\u00e1n carpetas independientes y con espacios en los nombres. Debido a lo engorroso de tener que escapar este tipo de caracteres cada vez que se utilizan en el terminal, la tendencia es usar nombres sin espacios, sustituyendo estos por guiones (\"-\") o guiones bajos (\"_\") Creando archivos usando la redirecci\u00f3n Supongamos que quisi\u00e9ramos capturar la salida del comando \"ls\" como un archivo de texto que podemos manipular con posterioridad. Todo lo que tenemos que hacer es agregar el car\u00e1cter mayor que (\u201d>\u201d) al final de nuestra l\u00ednea de comando, seguido del nombre del archivo en el que escribir: ls > salida.txt No se imprimir\u00e1 nada por pantalla puesto que hemos redirigido la salida del comando al archivo salida.txt. En todo caso, podemos utilizar el comando \"cat\" para ver el contenido del archivo: cat output.txt Otro ejemplo de redirecci\u00f3n podr\u00edamos llevarlo a cabo utilizando el comando \"echo\", el cual simplemente imprime por pantalla los argumentos que recibe. Sin embargo, podr\u00edamos redirigir la salida a un archivo y crear ficheros nuevos: echo \"Esto es una prueba\" > test_1.txt echo \"Esto es otra prueba\" > test_2.txt echo \"Otra prueba m\u00e1s\" > test_3.txt ls Y para ver el contenido de los archivos podemos utilizar nuevamente \"cat\". Incluso podr\u00edamos pasarle el nombre de los 3 archivos simult\u00e1nemamente como argumentos: cat test_1.txt test_2.txt test_3.txt Cuando desee pasar varios nombres de archivo a un solo comando, existen algunos atajos \u00fatiles que pueden ahorrarle mucho escribir si los archivos tienen nombres similares. Se puede utilizar un signo de interrogaci\u00f3n (\"?\") Para indicar \"cualquier car\u00e1cter\" dentro del nombre del archivo. Se puede utilizar un asterisco (\u201d*\u201d) para indicar \u201ccero o m\u00e1s caracteres\u201d. A veces se los denomina caracteres \"comod\u00edn\". Un par de ejemplos pueden ayudar, los siguientes comandos hacen lo mismo: cat test_1.txt test_2.txt test_3.txt cat test_?.txt cat test_* Atenci\u00f3n Precisamente por las car\u00e1cteres comod\u00edn en los comandos, tampoco es recomendable usar signos de puntuaci\u00f3n en los nombres de los archivos, de otra forma habr\u00eda que \"escapar\" estos caracteres a la hora de trabajar en la l\u00ednea de comandos con los nombres de los archivos Observando la salida de ls , se puede ver que los \u00fanicos archivos o carpetas que comienzan por \"t\" son los tres archivos de prueba que acabamos de crear, por lo que incluso se podr\u00eda simplificar ese \u00faltimo comando a\u00fan m\u00e1s cat t* , lo que significa \"concatenar todos los archivos cuyos nombres comienzan con una t y van seguidos de cero o m\u00e1s caracteres \u201d. Usemos esta capacidad para unir todos nuestros archivos en un solo archivo nuevo y luego verlo: cat t* > combinado.txt cat combinado.txt Hay que tener cuidado puesto que la shell borra todo el contenido del archivo antes de escribir la salida del comando cat en \u00e9l. Debido a esto, debe tener mucha precauci\u00f3n al usar la redirecci\u00f3n para asegurarse de no sobrescribir accidentalmente un archivo que necesita. Si lo que queremos es a\u00f1adir al final del archivo en lugar de reemplazar el contenido del mismo, debemos poner un doble s\u00edmbolo de \"mayor que\": cat t* >> combinado.txt echo \"\u00a1He a\u00f1adido una l\u00ednea!\" >> combinado.txt cat combinado.txt Cuando el contenido del archivo es mayor de lo que se puede mostrar en la terminal, se necesita utilizar lo que se conoce como pager para que pagine la salida por el terminal. El pager m\u00e1s antiguo era more porque colocaba una l\u00ednea de texto que dec\u00eda \"--More--\" para indicar que a\u00fan hab\u00eda contenido por mostrar. Posteriormente surgi\u00f3 el pager less con el fin de reemplazar a more . less archivo_muy_largo.txt Al examinar un archivo utilizando less , se pueden utilizar las teclas de flecha arriba, flecha abajo, Re P\u00e1g, Av P\u00e1g, Inicio y Fin para desplazarse a trav\u00e9s del fichero. A prop\u00f3sito de las may\u00fasculas y min\u00fasculas Los sistemas Unix son \"case sensitive\", es decir, distinguen entre may\u00fasculas y min\u00fasculas, es decir, consideran que \u201cA.txt\u201d y \u201ca.txt\u201d son dos archivos diferentes. Ejecutando los siguientes comandos se terminar\u00eda con tres archivos distintos: echo \"Con minusculas\" > a.txt echo \"Con mayusculas\" > A.TXT echo \"Ambas mezcladas\" > A.txt Se debe tener precauci\u00f3n con esto puesto que Windows es \"case insensitive\" y no distinguir\u00eda entre esos tres archivos, los tratar\u00eda como uno solo. Buenas pr\u00e1cticas de nomenclatura Cuando se considera tanto la distinci\u00f3n entre may\u00fasculas y min\u00fasculas como el escape, una buena regla general es mantener los nombres de los archivos en min\u00fasculas, con solo letras, n\u00fameros, guiones bajos y guiones. Adem\u00e1s, aunque en linux los archivos no tienen extensi\u00f3n, se la pondremos con el fin de facilitar el trabajo. Moviendo y manipulando archivos Ahora que ya hemos aprendido a crear archivos, vemos que tareas comunes podemos realizar con ellos. Por ejemplo, si queremos mover nuestro archivo combinado.txt al directorio dir1 , usando el comando mv (move) : mv combinado.txt dir1 Para confirmar que el comando se ha ejecutado con \u00e9xito podemos utilizar el comando ls para ver que el fichero ya no est\u00e1 en el directorio de trabajo, luego con cd dir1 cambiar a ese directorio, hacer ls para ver que ahora el fichero est\u00e1 all\u00ed, y luego cd .. para movernos al directorio de trabajo nuevamente. Los dos puntos nos permiten indicarle a un comando el directorio inmediatamente superior al que estamos. O tambi\u00e9n podemos ahorrarnos la mayor parte de este trabajo de escritura pasando una ruta directamente al comando ls consultar directamente el contenido de ese directorio: ls dir1 Si ahora quisi\u00e9ramos devolver el archivo combinado.txt al directorio padre, tendr\u00edamos dos opciones: Entrar en dir1 con cd y usar mv combinado.txt .. . De la misma manera que dos puntos ( ..) representan el directorio padre, por lo que .se puede usar un solo punto ( ) para representar el directorio de trabajo actual Como sabemos que solo hay un archivo en dir1 , podemos usar \u201c*\u201d para que coincida con cualquier nombre de archivo en ese directorio, ahorr\u00e1ndonos escribir m\u00e1s comandos. Nuestro comando para mover el archivo de nuevo al directorio de trabajo se convierte en esto (se debe tener en cuenta el espacio antes del punto, ya que hay dos par\u00e1metros que se pasan a mv ): mv dir1/* . El comando mv nos permite mover m\u00e1s de un fichero a la vez. Si se le pasa m\u00e1s de dos argumentos, el \u00faltimo se toma como el directorio de destino y los otros se consideran archivos (o directorios) a mover: mv combinado.txt test_* dir3 dir2 ls ls dir2 Si quisi\u00e9ramos mover una vez m\u00e1s el archivo combinado.txt a un directorio llamado dir6, que estar\u00e1 dentro del directorio dir5, que a su vez est\u00e1 dentro del directorio dir4 y todos ellos dentro de nuestro directorio de trabajo, har\u00edamos: mv dir2/combinado.txt dir4/dir5/dir6 ls dir2 ls dir4/dir5/dir6 Es decir, indicando las rutas adecuadas de directorios, podremos ejecutar este tipo de comandos desde cualquier lugar en el sistema de archivos o directorios. Si ahora lo que quisi\u00e9ramos fuera hacer una copia del archivo combinado.txt en nuestro directorio de trabajo, podr\u00edamos hacer dicha copia y comprobarla con la siguiente secuencia de comandos: cp dir4/dir5/dir6/combinado.txt . ls dir4/dir5/dir6 ls Si adem\u00e1s nos vi\u00e9ramos en la necesidad de cambiarle el nombre a un archivo o carpeta, Unix interpreta este hecho como que se est\u00e1 moviendo un archivo a otro, por ello haremos uso de mv , como por ejemplo: mv backup_combinado.txt combinado_backup.txt ls De la misma forma, mv nos permite renombrar directorios: mv \"carpeta 1\" carpeta_1 mv \"carpeta 2\" carpeta_2 mv \"carpeta 3\" carpeta_3 mv \"carpeta 4\" carpeta_4 mv \"carpeta 5\" carpeta_5 mv \"carpeta 6\" carpeta_6 ls Eliminar archivos y carpetas Ahora que ya sabemos c\u00f3mo mover, copiar y renombrar archivos y directorios, \u00fanicamente nos queda saber c\u00f3mo eliminarlos. Para ello usamos el comando rm (remove): rm dir4/dir5/dir6/combinado.txt Adem\u00e1s de archivos, se podr\u00eda intentar eliminar directorios que no hagan falta, como por ejemplo: \u00a1Wow! \u00bfA qu\u00e9 se debe ese error? Pues que por motivos de seguridad o precauci\u00f3n, a pesar de que rm permite elminar miles de archivos con un \u00fanico comando, no permite eliminar un directorio completo. Para ello necesitaremos el comando rmdir : A pesar que las carpetas de la 1 a la 5 se han eliminado, las 6 nos ha dado un error. Esto es porque el comando mkdir , una vez m\u00e1s por motivos de precacuci\u00f3n, exige que la carpeta est\u00e9 vac\u00eda para eliminarla. No obstante, la tarea m\u00e1s habitual cuando realmente se est\u00e1 seguro de que se desea eliminar un directorio y todo lo que contiene, es utilizar el comando rm de forma recursiva, usando el switch u opci\u00f3n -r : Recordatorio : aunque rm -r es r\u00e1pido y eficaz, tambi\u00e9n es peligroso. Es m\u00e1s seguro eliminar archivos expl\u00edcitamente para borrar un directorio, luego cd .. al padre antes de usar rmdir para eliminarlo. \u00a1Peligro! A diferencia de las interfaces gr\u00e1ficas, rm no mueve archivos a ninguna carpeta llamada \"papelera\" o similar. En cambio, los elimina total e irrevocablemente. Se debe tener mucho cuidado con los par\u00e1metros que usa con rm para asegurarno de que solo est\u00e1n eliminando los archivos deseados. Y se debe tener especial cuidado al usar comodines, ya que es f\u00e1cil eliminar accidentalmente m\u00e1s archivos de los que se pretend\u00eda. Un car\u00e1cter \"espacio\" equivocado en el comando puede cambiarlo por completo: rm t* significa \"eliminar todos los archivos que comienzan con t\", mientras que rm t * significa \"eliminar el archivo t as\u00ed como cualquier archivo cuyo nombre conste de cero o m\u00e1s caracteres, que ser\u00eda todo en el \u00a1directorio! Si no se est\u00e1 seguro, se puede usar la opci\u00f3n -i(interactive opcional) del rm que pedir\u00e1 que se confirme la eliminaci\u00f3n de cada archivo. Un poco de fontaner\u00eda (tuber\u00edas) A pesar de todos los avances t\u00e9cnicos de las \u00faltimas d\u00e9cadas, el texto sigue jugando un papel fundamental en la inform\u00e1tica. La suerte es que en Linux existen m\u00faltiples herramientas excepcionales para el manejo de texto. Comenzando con algo simple, \u00bfc\u00f3mo podr\u00edamos contar las l\u00edneas del archivo combinado.txt? Simple, con el comando wc (word count) , usando la opci\u00f3n -l con el fin de indicarle que \u00fanicamente queremos contar l\u00edneas: wc -l combinado.txt De manera similar, si quisi\u00e9ramos saber cu\u00e1ntos archivos y carpetas hay en nuestro directorio home (~) y contarlos, podr\u00edamos hacer lo siguiente: ls ~ | wc -l Esto es lo que se conoce como un pipe o tuber\u00eda. La l\u00ednea de comandos de Unix permite tomar la salida de un comando y con ella alimentar la entrada del siguiente comando. Esto es lo que conoce como canalizar los datos de un comando a otro y para ello se utiliza el car\u00e1cter \"|\" . Los espacios alrededor del car\u00e1cter de tuber\u00eda no tienen importancia, este comando por ejemplo funcionar\u00eda perfectamente: ls /etc | wc -l \u00a1Uf! Son bastantes archivos. Si quisi\u00e9ramos enumerarlos todos, claramente llenar\u00eda m\u00e1s de una pantalla. Como ya hemos visto anteriormente, cuando un comando produce una gran cantidad de resultados, es mejor usar less para verlo, y ese consejo a\u00fan se aplica cuando se usa una tuber\u00eda (recordad, presionad q para salir): ls /etc | less Una vuelta de tuerca m\u00e1s ser\u00eda saber cu\u00e1ntas l\u00edneas sin repetir tiene el archivo combinado.txt , es decir, cu\u00e1ntas l\u00edneas son sin contar las repetidas. El comando que nos permite hacer esto en Unix es uniq : Parece que se est\u00e1n eliminando muy pocas, si es que hay alguna, de nuestras l\u00edneas duplicadas. Para entender por qu\u00e9, necesitamos mirar la documentaci\u00f3n del comando. La mayor\u00eda de las herramientas de l\u00ednea de comandos vienen con un breve (y a veces no tan breve) manual de instrucciones, se accede a trav\u00e9s del comando man . La salida se canaliza autom\u00e1ticamente a trav\u00e9s del paginador less , por lo que podremos movernos hacia adelante y hacia atr\u00e1s,presionando finalmente \"q\" cuando queramos salir: man uniq El formato de las p\u00e1ginas de manual es a menudo conciso, se debe pensar en ellas m\u00e1s como una descripci\u00f3n general r\u00e1pida de un comando que como un tutorial completo. A menudo son muy t\u00e9cnicas, pero generalmente se puede omitir la mayor parte del contenido y simplemente buscar los detalles de la opci\u00f3n o el argumento en el que estamos interesados. La p\u00e1gina de manual de uniq es un ejemplo t\u00edpico, ya que comienza con una breve descripci\u00f3n de una l\u00ednea del comando, pasa a una sinopsis de c\u00f3mo usarlo y luego tiene una descripci\u00f3n detallada de cada opci\u00f3n o par\u00e1metro. Pero aunque las p\u00e1ginas de manual son invaluables, tambi\u00e9n pueden ser impenetrables. Se han de utilizar mejor cuando se necesita un recordatorio de un interruptor/switch/opci\u00f3n o par\u00e1metro en particular, en lugar de como un recurso general para aprender a usar la l\u00ednea de comandos. Sin embargo, la primera l\u00ednea de la secci\u00f3n DESCRIPCI\u00d3N responde a la pregunta de por qu\u00e9 no se han eliminado las l\u00edneas duplicadas: solo funciona en l\u00edneas coincidentes adyacentes. La pregunta, entonces, es c\u00f3mo reorganizar las l\u00edneas en nuestro archivo para que las entradas duplicadas est\u00e9n en l\u00edneas adyacentes. Si tuvi\u00e9ramos que ordenar el contenido del archivo alfab\u00e9ticamente, eso ser\u00eda suficiente. Unix ofrece un comando para hacer exactamente eso, sort . Una revisi\u00f3n r\u00e1pida del man muestra que podemos pasar un nombre de archivo directamente al comando, as\u00ed que veamos qu\u00e9 le hace a nuestro archivo: sort combinado.txt | less Deber\u00edis poder ver que las l\u00edneas se han reordenado y ahora se han adecuado para conectarlas directamente con uniq . Finalmente podemos completar nuestra tarea de contar las l\u00edneas \u00fanicas en el archivo: sort combinado.txt | uniq | wc -l Como se puede ver, la capacidad de canalizar datos de un comando a otro, creando largas cadenas para manipular sus datos, es una herramienta poderosa. Por esta raz\u00f3n, ver\u00e9is que se usan con bastante frecuencia en las l\u00ednea de comandos. Una cadena larga de comandos puede parecer intimidante al principio, pero recordad que se puede dividir incluso la cadena m\u00e1s larga en comandos individuales (y mirar sus p\u00e1ginas de manual) para comprender mejor lo que est\u00e1 haciendo. La l\u00ednea de comandos y el superusuario El superusuario es, como su nombre indica, un usuario con superpoderes. En los sistemas m\u00e1s antiguos, era un usuario real, con un nombre de usuario real (casi siempre \u201croot\u201d) que pod\u00eda iniciar sesi\u00f3n como si tuviera la contrase\u00f1a. En cuanto a esos superpoderes: root puede modificar o eliminar cualquier archivo en cualquier directorio del sistema, independientemente de qui\u00e9n sea el propietario; root puede reescribir las reglas del firewall o iniciar servicios de red que potencialmente podr\u00edan abrir la m\u00e1quina a un ataque; root puede apagar la m\u00e1quina incluso si otras personas todav\u00eda la est\u00e1n usando. En resumen, root puede hacer casi cualquier cosa, saltando f\u00e1cilmente las salvaguardas que generalmente se implementan para evitar que los usuarios sobrepasen sus l\u00edmites. Por supuesto, una persona que haya iniciado sesi\u00f3n como root es tan capaz de cometer errores como cualquier otra persona. Los anales de la historia de la inform\u00e1tica est\u00e1n llenos de historias de un comando mal escrito que borr\u00f3 todo un sistema de archivos o que acab\u00f3 con un servidor esencial. Adem\u00e1s existe la posibilidad de un ataque malicioso: si un usuario inicia sesi\u00f3n como root y abandona su escritorio, no es demasiado complicado para un colega descontento saltar a su m\u00e1quina y causar estragos. En un esfuerzo por reducir estos problemas, muchas distribuciones de Linux comenzaron a fomentar el uso del comando su . Es la abreviatura de 'superuser' y nos permite cambiar a otro usuario de la m\u00e1quina sin tener que hacer logout y login de nuevo. Cuando se usa sin argumentos, asume que se desea cambiar al usuario root, pero puede pasarle un nombre de usuario para cambiar a una cuenta de usuario espec\u00edfica. Fomentando el uso de su el objetivo era persuadir a los administradores para que pasaran la mayor parte de su tiempo usando una cuenta normal, que s\u00f3lo cambiaran a la cuenta de superusuario cuando lo necesitaran y luego usaran el comando logout (o el atajo Ctrl-D ) tan pronto como fuera posible para regresar a su usuario normal. Al minimizar la cantidad de tiempo que se pasa conectado como root , el uso de su reduce la ventana de oportunidad para cometer un error catastr\u00f3fico. A pesar de eso, siendo la naturaleza humana lo que es, muchos administradores han sido culpables de dejar abiertos terminales de larga duraci\u00f3n en los que sol\u00edan hacer su para cambiar a la cuenta de root. En ese sentido, sufue solo un peque\u00f1o paso adelante en materia de seguridad. Cuando se utiliza su toda la sesi\u00f3n del terminal se cambia al otro usuario. Los comandos que no necesitan acceso de root, algo tan mundano como pwd o `ls , se ejecutar\u00edan bajo los auspicios y permisos del superusuario, aumentando el riesgo de que un error en el programa cause problemas importantes. Peor a\u00fan, si pierde la pista de qu\u00e9 usuario est\u00e1 actuando en cada momento, se puede eejecutar un comando que fuera bastante benigno cuando se ejecuta como usuario, pero que podr\u00eda destruir todo el sistema si se ejecuta como root . Es mejor deshabilitar la cuenta de root por completo y luego, en lugar de permitir sesiones de terminal de larga duraci\u00f3n con poderes peligrosos, requerir que el usuario solicite espec\u00edficamente derechos de superusuario por comando. La clave de este enfoque es un comando llamado sudo ( \u201c s witch u ser and do this command\u201d). sudo se utiliza para preceder a un comando que debe ejecutarse con privilegios de superusuario. Se utiliza un archivo de configuraci\u00f3n para definir qu\u00e9 usuarios pueden usar sudo y qu\u00e9 comandos pueden ejecutar. Cuando se ejecuta un comando como este, se le solicita al usuario su propia contrase\u00f1a, que luego se almacena en cach\u00e9 durante un per\u00edodo de tiempo (por defecto es de 15 minutos), por lo que si necesita ejecutar varios comandos de nivel de superusuario, no se le siguen pidiendo cada vez. Un ejemplo de todo lo comentado hasta ahora, ser\u00eda: \u00a1Cuidado con sudo! Si se indica que debe ejecutarse un comando con sudo , asegur\u00e1os de comprender lo que hace el comando antes de continuar. Ejecutar con sudo le da a ese comando los mismos poderes que un superusuario. Archivos ocultos Este tipo de archivos se usan com\u00fanmente en sistemas Linux para almacenar configuraciones y/o datos de configuraci\u00f3n y generalmente se ocultan simplemente para que no abarroten la vista de sus propios archivos. No hay nada especial en un archivo o carpeta ocultos, aparte de su nombre: simplemente comenzar un nombre con un punto (\u201d.\u201d) Es suficiente para que desaparezca. cd /tmp/tutorial ls mv combinado.txt .combinado.txt ls A\u00fan se puede trabajar con el archivo oculto asegur\u00e1ndose de incluir el punto cuando especifique su nombre de archivo: cat .combinado.txt mkdir .oculto mv .combinado.txt .oculto less .oculto/.combined.txt Si se ejecuta ls , se ver\u00e1 que el directorio .oculto est\u00e1, como era de esperar, oculto. A\u00fan se puede enumerar su contenido usando ls .hidden , pero como s\u00f3lo contiene un solo archivo que est\u00e1, as\u00edmismo, oculto, no se obtendr\u00e1n muchos resultados. Sin embargo, se puede utilizar la opci\u00f3n/switch -a del comando `ls para hacer que se muestre todo en un directorio, incluyendo los archivos y carpetas ocultos: ls ls -a ls .hidden ls -a .hidden Estos archivos normalmente almacenan la configuraci\u00f3n personal, y es as\u00ed como los sistemas Unix siempre han ofrecido la capacidad de tener configuraciones a nivel de sistema (generalmente en /etc) que pueden ser anuladas por usuarios individuales (cortes\u00eda de archivos ocultos en su directorio de inicio).","title":"Entornos Linux"},{"location":"section/EntLinux/#estructura-de-ficheros","text":"Un sistema de archivos, llamado com\u00fanmente File System o FS, determina la organizaci\u00f3n de los datos en un soporte de almacenamiento, y por tanto, c\u00f3mo gestiona y organiza el sistema operativo los archivos. Linux es, como todo Unix, un sistema operativo completamente orientado a archivos. Se representa todo (o casi todo) con un archivo, tanto los datos (archivos de datos de cualquier tipo, como una imagen o un programa) como los perif\u00e9ricos (terminales, ratones, teclado, tarjeta sonido, etc.) o incluso los medios de comunicaci\u00f3n (sockets, tuber\u00edas nombradas, etc.). Se puede decir que el sistema de archivos es el coraz\u00f3n de cualquier sistema Unix. Un archivo es una entidad que almacena datos y programas. Se compone de contenido y metadatos (tama\u00f1o del archivo, propietario, fecha de creaci\u00f3n, permisos). Los archivos est\u00e1n organizados en directorios. Un directorio es un archivo que almacena otros archivos. Los diferentes tipos de archivos incluyen: Archivos regulares que almacenan datos y programas. Directorios que contienen otros archivos. Archivos especiales que se utilizan para entrada y salida. Todo en Linux es un archivo , por lo que saber c\u00f3mo manipularlos es muy importante. As\u00ed pues, en la secci\u00f3n correspondiente, veremos las operaciones b\u00e1sicas con archivos mediante el terminal. La estructura de los directorios de Linux, as\u00ed como su contenido y funciones, viene definida en el denominado Filesystem Hierarchy Standard o FHS por sus siglas en ingl\u00e9s, que en otras palabras viene a ser el est\u00e1ndar de jerarqu\u00eda para los sistemas de archivos en sistemas Linux y otros derivados de UNIX. Como pod\u00e9is ver en la siguiente imagen, todo el \u00e1rbol de parte de una ra\u00edz com\u00fan denominada root y que se simboliza por una barra inclinada. A\u00fan as\u00ed, esto no significa que varios de ellos no puedan estar en particiones separadas del resto. De hecho, en muchas distros GNU/Linux es una pr\u00e1ctica muy com\u00fan el hecho ubicar ciertos directorios en particiones separadas del resto. La FHS distingue entre lo que ser\u00edan directorios est\u00e1ticos, que son aquellos que contienen binarios, bibliotecas, documentaci\u00f3n, etc., de los din\u00e1micos, que son aquellos que requieren de acciones m\u00e1s a menudo, tales como copias de seguridad, etc. Tambi\u00e9n podemos diferencias claramente lo que son los directorios compartibles, que significa que contienen ficheros que pueden utilizarse desde otros dispositivos, de los no compartibles, que solo pueden utilizarse desde el dispositivo en el que se encuentran.","title":"Estructura de ficheros"},{"location":"section/EntLinux/#directorio-raiz-o","text":"Toda la estructura de directorios en los sistemas basados en UNIX parte de un directorio ra\u00edz tambi\u00e9n llamado directorio root y que se simboliza por una barra inclinada o /. De este directorio, es desde donde nacen todo el resto de directorios, independientemente que est\u00e9n almacenados f\u00edsicamente en discos o unidades separadas. Cualquier direcci\u00f3n de archivo o carpeta en Linux empieza por el directorio ra\u00edz o /, seguido de todos los directorios y subdirectorios que que lo contienen, separados cada uno de ellos por /. A continuaci\u00f3n conocer\u00e1s con m\u00e1s en detalle a todos los directorios principales que parten del directorio ra\u00edz, junto con sus subdirectorios m\u00e1s importantes y los ficheros que suelen contener.","title":"Directorio ra\u00edz o \"/\""},{"location":"section/EntLinux/#directorios-bin-sbin","text":"El directorio /bin es un directorio est\u00e1tico y es donde se almacenan todos los binarios necesarios para garantizar las funciones b\u00e1sicas a nivel de usuario. Solo almacena los ejecutables de usuario, ya que los binarios necesarios para tareas administrativas gestionadas por el usuario root o superusuario del sistema se encuentran en el directorio /sbin. Incluye tambi\u00e9n los binarios que permiten la ejecuci\u00f3n de varias utilidades est\u00e1ndar de la terminal de Linux, concretamente cat, cd, cp, echo, grep, gzip, kill, ls, mv, rm, ping, su, ps, tar y vi. El directorio /sbin hace lo mismo pero para los binarios relativos tareas propias del sistema operativo, y que solamente pueden ser gestionadas por el usuario root, tales como el arranque, tareas de restauraci\u00f3n, reparaci\u00f3n, etc.","title":"Directorio/s bin, sbin"},{"location":"section/EntLinux/#directorio-boot","text":"Es un directorio est\u00e1tico y contiene los archivos necesarios para arrancar el sistema. Los archivos del cargador de arranque GRUB y los kernels de Linux se almacenan aqu\u00ed, por ejemplo. Sin embargo, los archivos de configuraci\u00f3n del cargador de arranque no se encuentran aqu\u00ed, est\u00e1n en /etc con los otros archivos de configuraci\u00f3n. A la hora de instalar el sistema es importante prever bien el espacio que se le vaya a dar a la partici\u00f3n, ya que a la larga, con la acumulaci\u00f3n de diferentes actualizaciones del Kernel, es com\u00fan que se quede sin espacio. Si esto sucede, se pueden tener problemas a la hora de instalar futuras actualizaciones del n\u00facleo, y ser\u00e1 necesario hacer limpieza de versiones antiguas del kernel.","title":"Directorio /boot"},{"location":"section/EntLinux/#directorio-dev","text":"Este directorio incluye todos los dispositivos de almacenamiento, en forma de archivos especiales, conectados al sistema. Es decir, cualquier disco duro, partici\u00f3n, memoria USB, o CDROM conectado al sistema y que el sistema pueda entender como un volumen l\u00f3gico de almacenamiento. Siendo esto as\u00ed, ver\u00e9is que la ruta en la que se encuentra cualquier volumen (partici\u00f3n o dispositivo externo) conectado al sistema siempre empieza por /dev. Este es el directorio que contiene, por decirlo de alg\u00fan modo, la informaci\u00f3n de cada uno de los vol\u00famenes, a diferencia del directorio /media , que veremos m\u00e1s adelante, que lo que contiene son solo los puntos de montaje, pero no la informaci\u00f3n real de estos vol\u00famenes. Para ver esto en la pr\u00e1ctica, si abres una ventana de terminal y ejecutas el comando sudo fdisk -l , ver\u00e1s la estructura de particiones de tu sistema. En una instalaci\u00f3n t\u00edpica de cualquier distro GNU/Linux suele ser la siguiente: /dev/sda1 - Partici\u00f3n principal /dev/sda2 - Partici\u00f3n extendida /dev/sda5 - Partici\u00f3n Swap Estos no son archivos reales como los conocemos, pero aparecen como archivos; por ejemplo, /dev/sda representa la primera unidad SATA del sistema. Eso en cuanto a particiones. Si se trata de un dispositivo externo, el volumen estar\u00e1 igualmente dentro de /dev, pero en este caso var\u00eda el nombre que el sistema le asigna a dicho volumen. Generalmente la estructura suele ser la siguiente (ejecutando nuevamente el comando sudo fdisk -l con un dispositivo externo conectado puede comprobarse). /dev/sdb1 /dev/sdb2 /dev/sdb3 ... Este directorio tambi\u00e9n contiene pseudodispositivos, que son dispositivos virtuales que en realidad no se corresponden con el hardware. Por ejemplo, /dev/random produce n\u00fameros aleatorios. Otro ejemplo ser\u00eda el de /dev/null , un dispositivo especial que no produce salida y descarta autom\u00e1ticamente todas las entradas; cuando canaliza la salida de un comando a /dev/null , la descarta.","title":"Directorio /dev"},{"location":"section/EntLinux/#directorio-etc","text":"El directorio /etc contiene archivos de configuraci\u00f3n, que generalmente se pueden editar a mano en un editor de texto. Se debe tener en cuenta que el directorio /etc contiene archivos de configuraci\u00f3n de todo el sistema, adem\u00e1s de las aplicaciones y programas instaladas posteriormente; los archivos de configuraci\u00f3n espec\u00edficos del usuario se encuentran en el directorio de inicio de cada usuario. Es un directorio que deber\u00eda contener \u00fanicamente ficheros de configuraci\u00f3n, y no deber\u00eda contener binarios.","title":"Directorio /etc"},{"location":"section/EntLinux/#directorio-lib","text":"Incluye las bibliotecas esenciales que son necesarias para que se puedan ejecutar correctamente todos los binarios que se encuentran en los directorios /bin y /sbin , as\u00ed como los m\u00f3dulos del propio kernel. En los sistemas operativos de 64 bits, adem\u00e1s de /lib existe otro directorio denominado /lib64 , referida a las bibliotecas para aplicaciones de 64 bits.","title":"Directorio lib"},{"location":"section/EntLinux/#directorio-media","text":"Representa el punto de montaje de todos los vol\u00famenes l\u00f3gicos que se montan temporalmente. Es decir, El directorio /media contiene subdirectorios donde se montan los dispositivos de medios extra\u00edbles insertados en el ordenador. En la mayor\u00eda de distribuciones GNU/Linux, desde hace ya alg\u00fan tiempo, cada vez que se monta una unidad externa, partici\u00f3n, etc., esta se monta dentro del directorio /media y a su vez dentro de un directorio especifico dependiendo del usuario del sistema que monta el volumen. De este modo, si en un sistema hay varios usuarios, pongamos User1 y User2, los puntos de montaje de los vol\u00famenes que montan cada uno de ellos se mostraran en directorios separados tal como as\u00ed: /media/User1 /media/User2","title":"Directorio media"},{"location":"section/EntLinux/#directorio-opt","text":"El directorio /opt contiene subdirectorios para paquetes de software opcionales. Es com\u00fanmente utilizado por software propietario que no obedece a la jerarqu\u00eda del sistema de archivos est\u00e1ndar; por ejemplo, un programa propietario puede volcar sus archivos en /opt/NombreAplicacion cuando se instala. Antiguamente se sol\u00eda utilizar el directorio mnt para estas funciones, pero actualmente, la mayor\u00eda de distribuciones hacen uso de media.","title":"Directorio opt"},{"location":"section/EntLinux/#directorio-proc","text":"Este directorio contiene informaci\u00f3n de los procesos y aplicaciones que se est\u00e1n ejecutando en un momento determinado en el sistema, pero realmente no guarda nada como tal, ya que lo que almacena son archivos virtuales, por lo que el contenido de este directorio es nulo.","title":"Directorio proc"},{"location":"section/EntLinux/#directorio-root","text":"El directorio /root es el directorio de inicio del usuario root. En lugar de estar ubicado en /home/root , est\u00e1 ubicado en /root . Es distinto de / , que es el directorio ra\u00edz del sistema.","title":"Directorio /root"},{"location":"section/EntLinux/#directorio-tmp","text":"Las aplicaciones almacenan archivos temporales en el directorio /tmp . Estos archivos generalmente se eliminan cada vez que se reinicia su sistema y pueden ser eliminados en cualquier momento por utilidades como tmpwatch. Las aplicaciones programadas para almacenar archivos en este directorio deben asumir que solo ser\u00e1n recuperables en la sesi\u00f3n actual. En este sentido, hay otro subdirectorio, /var/tmp , dispuesto igualmente para el almacenamiento de archivos temporales, pero cuyo contenido no se borra de forma autom\u00e1tica tras el reinicio del sistema.","title":"Directorio tmp"},{"location":"section/EntLinux/#directorio-usr","text":"El directorio /usr contiene aplicaciones y archivos utilizados por los usuarios, a diferencia de las aplicaciones y archivos utilizados por el sistema, incluyendo todo el software instalado a trav\u00e9s de los gestores de paquetes de cada distribuci\u00f3n. Por ejemplo, las aplicaciones no esenciales se encuentran dentro del directorio /usr/bin en lugar del directorio /bin y los binarios de administraci\u00f3n del sistema no esenciales se encuentran en el directorio /usr/sbin en lugar del directorio /sbin . Las bibliotecas para cada uno se encuentran dentro del directorio /usr/lib . El directorio /usr tambi\u00e9n contiene otros directorios; por ejemplo, los archivos independientes de la arquitectura, como los gr\u00e1ficos, se encuentran en /usr/share : /usr/bin /usr/include /usr/lib /usr/local /usr/sbin /usr/share /usr/src El directorio /usr/local es donde se instalan las aplicaciones compiladas localmente de forma predeterminada; esto evita que arruinen el resto del sistema","title":"Directorio usr"},{"location":"section/EntLinux/#directorio-var","text":"Este directorio contiene varios archivos con informaci\u00f3n del sistema, como archivos de logs, emails de los usuarios del sistema, bases de datos, informaci\u00f3n almacenada en la cach\u00e9 o informaci\u00f3n relativa a los paquetes de aplicaciones almacenados en /opt . En cierto modo se podr\u00eda decir que act\u00faa a modo de registro del sistema. Podr\u00eda decirse que el directorio /var es la contraparte \"escriturable\" del directorio /usr , que debe ser de solo lectura en el funcionamiento normal. Los archivos de registro y todo lo dem\u00e1s que normalmente se escribir\u00eda en /usr durante el funcionamiento normal se escriben en el directorio /var .","title":"Directorio var"},{"location":"section/EntLinux/#directorio-home","text":"El directorio /home contiene una carpeta de inicio para cada usuario. Por ejemplo, si el nombre de usuario es raul, habr\u00e1 una carpeta de inicio ubicada en /home/raul . Esta carpeta de inicio contiene los archivos de datos del usuario y los archivos de configuraci\u00f3n espec\u00edficos del usuario (configuraciones de programas, por ejemplo). Cada usuario solo tiene acceso de escritura \u00fanicamente a su propia carpeta de inicio y debe convertirse en root para poder tener privilegios que le permitan modificar otros archivos en el sistema. Para visualizar los ficheros ocultos dentro del directorio individual de cada usuario, se puede usar la combinaci\u00f3n de comandos CTRL + H en modo gr\u00e1fico. Todos los archivos y carpetas ocultas en Linux empiezan por un punto, seguido del nombre. En muchas distribuciones es una pr\u00e1ctica recomendada el hecho de ubicar el directorio /home es una partici\u00f3n separada del resto, por tal de facilitar que, en caso de reinstalar el sistema operativo, puedas mantener intacta la partici\u00f3n de la /home , y de este modo mantener todos los archivos personales.","title":"Directorio home"},{"location":"section/EntLinux/#usuarios-y-grupos","text":"Un usuario es cualquiera que use un ordenador. En este caso, estamos describiendo los nombres que representan a esos usuarios. Puede ser Pol o Mart\u00ed, y pueden usar los nombres superc0der o Pirate en lugar de su nombre real. Lo \u00fanico que importa es que la computadora tenga un nombre para cada cuenta que cree, y es este nombre por el que una persona obtiene acceso para usar la computadora. Algunos servicios del sistema tambi\u00e9n se ejecutan utilizando cuentas de usuario restringidas o privilegiadas. La administraci\u00f3n de los usuarios se realiza con fines de seguridad al limitar el acceso de ciertas maneras espec\u00edficas. El superusuario (root) tiene acceso completo al sistema operativo y su configuraci\u00f3n; est\u00e1 destinado solo para uso administrativo. Los usuarios sin privilegios pueden usar los programas su y sudo para la escalada de privilegios controlada. Cualquier persona puede tener m\u00e1s de una cuenta, siempre que utilicen un nombre diferente para cada una de ellas. Adem\u00e1s, hay algunos nombres reservados que no se pueden usar, como \u00abroot\u00bb. Los usuarios pueden aglutinarse en un \u00abgrupo\u00bb y, del mismo modo, pueden a\u00f1adirse a un grupo existente para utilizar el acceso privilegiado que dicho grupo concede. Los grupos de usuarios juegan un papel esencial en los sistemas Linux. Gracias a ellos tenemos una manera muy f\u00e1cil de seleccionar grupos de usuarios a los que se les permite compartir archivos entre ellos. Tambi\u00e9n proporcionan a los administradores de sistemas una manera m\u00e1s efectiva y sencilla de gestionar los privilegios de los usuarios puesto que permiten asignar privilegios a grupos completos en lugar de a usuarios individuales.","title":"Usuarios y grupos"},{"location":"section/EntLinux/#permisos","text":"Aunque hay multitud de caracter\u00edsticas de seguridad integradas en los sistemas basados \u200b\u200ben Linux, puede existir una vulnerabilidad potencial muy importante cuando se otorga el acceso al sistema a los usuarios. Pueden aparecer problemas cuando no se han asignado los permisos adecuados a los archivos y directorios.","title":"Permisos"},{"location":"section/EntLinux/#grupos-de-permisos","text":"Cada archivo y directorio tiene tres grupos de permisos basados \u200b\u200ben usuarios: Propietario: los permisos de propietario se aplican solo al propietario del archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Grupo: los permisos de grupo se aplican solo al grupo que se ha asignado al archivo o directorio, no afectar\u00e1n las acciones de otros usuarios. Todos los usuarios: los permisos de todos los usuarios se aplican a todos los dem\u00e1s usuarios del sistema; este es el grupo de permisos que m\u00e1s desea ver.","title":"Grupos de permisos"},{"location":"section/EntLinux/#tipos-de-permisos","text":"Cada archivo o directorio tiene tres tipos de permisos b\u00e1sicos: Lectura (read/r): el permiso de lectura se refiere a la capacidad de un usuario para leer el contenido del archivo. El permiso de lectura en un directorio permite listar su contenido. Escritura (write/w): los permisos de escritura se refieren a la capacidad de un usuario para escribir o modificar un archivo. En un directorio permite crear, eliminar o modificar el nombre de un archivo. En un hipot\u00e9tico caso donde tuvi\u00e9ramos permiso de escritura en un archivo pero no en el directorio en el que est\u00e1 ubicado, podr\u00edamos modificar el contenido del archivo pero no su nombre, ni moverlo de sitio, ni eliminarlo del directorio. Ejecuci\u00f3n (execution/x): el permiso de ejecuci\u00f3n afecta la capacidad de un usuario para ejecutar un archivo o ver el contenido de un directorio. Tip Podemos inspeccionar con detalle los permisos de arhivos y directorios con el comando: ls -l","title":"Tipos de permisos"},{"location":"section/EntLinux/#como-se-cambian-los-permisos-en-linux","text":"Para cambiar los permisos de archivos y directorios en GNU/Linux, disponemos de 3 comandos principales: chmod: cambiar permisos del archivo o directorio: chmod [ permisos ][ archivo/directorio ][ opciones ] chown: cambiar el propietario del archivo o directorio: chown [ nuevo usuario propietario ][ archivo/directorio ][ opciones ] chgrp: cambiar el grupo del archivo o directorio: chgrp [ nuevo grupo ][ archivo/directorio ][ opciones ] Existen dos formas de cambiar los permisos de archivos y directorios en Linux: Modo simb\u00f3lico: con notaci\u00f3n basada en caracteres Modo absoluto: con notaci\u00f3n num\u00e9rica, seg\u00fan el sistema octal o en base 8 , cuyos valores de forma resumida puedne verse en la imagen a continuaci\u00f3n: As\u00ed pues, una tabla resumen en cu\u00e1nto a los permisos vistos, ser\u00eda la siguiente: Valor Permisos Descripci\u00f3n 0 --- Sin permisos 1 --x Ejecuci\u00f3n 2 -w- Lectura 3 -wx Lectura + ejecuci\u00f3n 4 r-- Lectura 5 r-x Lectura + ejecuci\u00f3n 6 rw- Lectura + escritura 7 rwx Lectura + escritura + ejecuci\u00f3n Los permisos utilizando la notaci\u00f3n num\u00e9rica en sistema octal, se asignan en tuplas de 3 (usuario/grupo/otros) y no es posible asignar s\u00f3lo para uno o dos de los elementos de la tupla. Algunos ejemplos de permisos en modo absoluto son: Notaci\u00f3n Significado rw------- (600) Permisos de lectura y escritura s\u00f3lo para el propietario rw-r--r-- (644) Permisos de lectura y escritura s\u00f3lo para el propietario y s\u00f3lo de lectura para el grupo y resto de usuarios rwxr-xr-x (755) Permisos de lectura, escritura y ejecuci\u00f3n para el usuario y de lectura y ejecuci\u00f3n para el grupo y resto de usuarios rwxrwxrwx (777) Usuario, grupo y resto de usuarios tienen todos los permisos sobre el fichero o directorio (\u00a1Cuidado!) rw-rw-rw- (666) Usuario, grupo y resto de usuarios pueden leer y escribir sobre el fichero o directorio(\u00a1cuidado!) Como ya hemos dicho es el comando chmod el utilizado en el terminal para cambiar los permisos de los usuarios. Puede usarse tanto con el modo absoluto como con el simb\u00f3lico. Un ejemplo para el formato absoluto ser\u00eda: chmod 600 archivo/directorio Y para el formato con caracteres chmod ugo+rw archivo/directorio Donde, en este \u00faltimo caso, los permisos rwx (lectura/escritura/ejecuci\u00f3n) pueden asignarse a: u - propietario g - grupo o - otros a - todos los usuarios Si utilizamos el operador + estaremos agregando permisos, si usamos el - los eliminaremos: chmod a-rw archivo1 chmod u+rwx archivo2 Ejemplos pr\u00e1cticos del uso de chmod para cambiar permisos de un archivo. Podemos utilizar tanto la forma absoluta, como la simb\u00f3lica: Modo absoluto Modo simb\u00f3lico Resultado chmod 700 archivo.gpg chmod u+rwx -rwx------ chmod 555 chmod ugo+rx -r-xr-xr-x chmod 666 -chmod ugo+rw rw-rw-rw-","title":"\u00bfC\u00f3mo se cambian los permisos en Linux?"},{"location":"section/EntLinux/#permisos-avanzados","text":"En GNU/Linux, adem\u00e1s de los 3 que hemos visto anteriormente, todav\u00eda existen otros tres permisos especiales adicionales que veremos a continuaci\u00f3n.","title":"Permisos avanzados"},{"location":"section/EntLinux/#bit-setuid","text":"En Linux, de forma predeterminada, cuando un usuario ejecuta un archivo, el archivo se inicia con los privilegios del usuario que lo ejecuta. Sin embargo, este comportamiento se puede cambiar si establecemos permisos especiales en archivos ejecutables. Setuid significa \"establecer ID de usuario\". Si configuramos el bit setuid en un archivo ejecutable, el archivo siempre se ejecuta con los privilegios del propietario del archivo, sin importar qui\u00e9n lo inicie. El bit setuid solo tiene sentido si est\u00e1 configurado en archivos ejecutables. No hay ning\u00fan significado pr\u00e1ctico si configuramos el bit setuid en un archivo o directorio no ejecutable. El comando passwd es un ejemplo con este bit especial aplicado: $ ls -l /bin/passwd -rwsr-xr-x 1 root root 63624 Dec 15 21 :06 /bin/passwd Observamos que el permiso de ejecuci\u00f3n para el propietario es una \"s\" min\u00fascula en lugar de la \"x\" habitual. Esta \"s\" indica que el archivo tiene el bit setuid establecido. El comando passwd siempre se ejecutar\u00e1 con privilegios de root sin importar qui\u00e9n lo inicie porque el propietario del archivo es root. Como ya sabemos, podemos usar el comando chmod para establecer el bit setuid en un archivo: chmod u+x archivo S\u00f3lo el propietario el archivo o el usuario o el usuario root puede establecer el bit setuid Un ejemplo pr\u00e1ctico de c\u00f3mo configurar este bit setuid en un archivo, de forma simb\u00f3lica: $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo $ chmod u+s archivo $ ls -l archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo En el modo absoluto, anteponemos un 4 a los permisos para indicar este bit: $ chmod 4755 archivo -rwsr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo Y para quitar este bit, en ambos modos: $ chmod u-s archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo y $ chmod 0755 archivo $ ls -l archivo -rwxr-xr-x 1 raul raul 0 Feb 2 12 :22 archivo Riesgo de seguridad El bit setuid podr\u00eda ser bastante \u00fatil en varias aplicaciones. Sin embargo, debemos tener cuidado al establecer esos permisos especiales, ya que pueden crear problemas de seguridad. Por ejemplo, un usuario normal puede obtener privilegios de superusuario ejecutando un programa que establece el UID como root y realizar una escalada de privilegios.","title":"Bit setuid"},{"location":"section/EntLinux/#bit-setgid","text":"","title":"Bit setgid"},{"location":"section/EntLinux/#bit-setgid-en-un-archivo","text":"setgid es la abreviatura de \"set group id\". Si configuramos el bit setgid en un archivo ejecutable, no importa qui\u00e9n inicie el archivo, se ejecuta con los privilegios del grupo propietario. El comando de localizaci\u00f3n es un ejemplo de un archivo con el conjunto de bits setgid : $ ls -l /usr/bin/locate -rwxr-sr-x 1 root locate 43048 Nov 13 18 :09 /usr/bin/locate Similar al bit setuid , notamos una \"s\" min\u00fascula en la salida de ls , excepto que est\u00e1 en la secci\u00f3n de grupo en lugar de en la secci\u00f3n de propietario. Para establecer este bit de modo simb\u00f3lico podemos utilizar: $ ls -l archivo2 -rwxr-xr-x 1 raul raul 0 Feb 2 22 :35 archivo2 $ chmod g+s archivo2 $ ls -l archivo2 -rwxr-sr-x 1 raul raul 0 Feb 2 22 :35 archivo2 Y de modo absoluto, anteponiendo un dos a los permisos: chmod 2755 archivo2","title":"Bit setgid en un archivo"},{"location":"section/EntLinux/#bit-setgid-en-un-directorio","text":"Si configuramos el bit setgid en un directorio, todos los archivos y subdirectorios reci\u00e9n creados en el directorio heredar\u00e1n el grupo de ese directorio. Sin embargo, los archivos y directorios existentes no aplicar\u00e1n el cambio de grupo. Veamos un ejemplo para aclarar este comportamiento. Primero, preparamos un directorio padre que contiene dos archivos: $ ls -ld padre drwxrwxrwx 2 root raul 4096 Feb 3 00 :33 padre/ $ ls -l padre total 2 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 existing_grp_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 existing_grp_invitado2 padre es propiedad del usuario root y del grupo raul. Contiene dos archivos e invitado es due\u00f1o de ambos. A continuaci\u00f3n, establezcamos el bit setgid en padre usando chmod: root# chmod g+s padre root# ls -ld padre drwxrwsrwx 2 root raul 4096 Feb 3 00 :33 padre/ Ahora, vamos a crear un nuevo archivo y un subdirectorio bajo el padre con root: root# touch padre/nuevo_root root# mkdir padre/nuevo_dir_root ``` Luego, verificaremos los propietarios del grupo de todos los archivos y subdirectorios en padre: root# ls -l padre total 4 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 grp_exist_invitado1 -rwxr-xr-x 1 invitado invitado 0 Feb 3 00 :30 grp_exist_invitado2 drwxr-sr-x 2 root raul 4096 Feb 3 00 :54 nuevo_dir_root/ -rw-r--r-- 1 root raul 0 Feb 3 00 :54 nuevo_arch_root En la salida anterior, vemos que los dos archivos existentes no han cambiado despu\u00e9s de que establecemos el bit setuid en padre. Sin embargo, el archivo y el subdirectorio reci\u00e9n creados son propiedad de raul en lugar de root , aunque root los cre\u00f3. Esto se debe a que el padre ten\u00eda establecido el bit setgid , y los archivos y directorios reci\u00e9n creados bajo \u00e9l heredaron el grupo del padre.","title":"Bit setgid en un directorio"},{"location":"section/EntLinux/#sticky-bit","text":"La misi\u00f3n del sticky bit es proteger los archivos dentro de un directorio. Si configuramos el sticky bit en un directorio, un archivo en este directorio solo se puede eliminar mediante una de las siguientes opciones: El due\u00f1o del archivo El due\u00f1o del directorio El usuario root En otras palabras, este permiso especial evita que un usuario elimine los archivos de otros usuarios en un directorio p\u00fablico. Un ejemplo t\u00edpico de sticky bit del mundo real es el directorio /tmp: $ ls -ld /tmp drwxrwxrwt 24 root root 980 Feb 3 21 :41 /tmp/ Debido a la \"w\" en la secci\u00f3n de permisos \"otros\", sabemos que cualquier usuario puede crear y eliminar cualquier archivo en el directorio /tmp . Pero si leemos la salida de ls anterior con atenci\u00f3n, vemos que el bit de permiso de ejecuci\u00f3n en la secci\u00f3n \"otro\" es una \"t\" min\u00fascula, en lugar de la \"x\" habitual. Esta \"t\" en min\u00fascula indica que el directorio / tmp tiene el bit fijo establecido. Con el sticky bit, cualquier usuario a\u00fan puede crear archivos bajo /tmp. Sin embargo, un usuario solo puede eliminar archivos de su propiedad.","title":"Sticky bit"},{"location":"section/EntLinux/#el-sticky-bit-en-un-directorio","text":"Para establecer el sticky bit en un directorio, a\u00fan podemos usar el comando chmod con el modo + t : chmod +t DIRECTORIO De otra forma, tambi\u00e9n podemos anteponer un \"1\" al modo de un directorio para establecer el sticky bit: chmod 1777 DIRECTORIO Tambi\u00e9n podemos eliminar el sticky bit de un directorio usando -t : chmod -t DIRECTORIO Como de costumbre, veamos un ejemplo para comprender c\u00f3mo el sticky bit puede proteger los archivos de un directorio y c\u00f3mo configurar y eliminar el sticky bit en un directorio. Comencemos por preparar un directorio p\u00fablico llamado p\u00fablico y permitir que todos los usuarios escriban en \u00e9l: $ ls -ld public drwxrwxrwx 2 root root 40 Feb 3 22 :22 public/ A continuaci\u00f3n, crearemos algunos archivos en p\u00fablico por diferentes usuarios: $ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo1_invitado -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22 :28 archivo_raul Hasta ahora, no hemos colocado el sticky bit en ninguna parte. Veamos si el usuario raul puede eliminar un archivo propiedad de un invitado: raul$ rm archivo1_invitado rm: remove write-protected regular empty archivo 'archivo1_invitado' ? y raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22 :28 archivo_raul Entonces, sin el sticky bit, podemos eliminar archivos propiedad de otros usuarios. Ahora, configuremos el sticky bit y veamos si hay alg\u00fan cambio: root# chmod +t public root# ls -ld public drwxrwxrwt 2 root root 80 Feb 3 22 :33 public/ root# su raul raul$ rm archivo2_invitado rm: remove write-protected regular empty archivo 'archivo2_invitado' ? y rm: cannot remove 'archivo2_invitado' : Operation not permitted raul$ ls -l -rw-r--r-- 1 invitado invitado 0 Feb 3 22 :28 archivo2_invitado -rw-r--r-- 1 raul raul 0 Feb 3 22 :28 archivo_raul Despu\u00e9s de configurar el sticky bit, los archivos en p\u00fablico solo pueden ser eliminados por los propietarios del archivo.","title":"El sticky bit en un directorio"},{"location":"section/EntLinux/#contrasenas-en-linux","text":"En este apartado se describe c\u00f3mo se implementan las contrase\u00f1as dentro del sistema operativo Unix tanto para sistemas administrados localmente como basados \u200b\u200ben red.","title":"Contrase\u00f1as en Linux"},{"location":"section/EntLinux/#el-archivo-etcpasswd","text":"Tradicionalmente, Unix usa el archivo /etc/passwd para realizar un seguimiento de cada usuario en el sistema. El archivo / etc / passwd contiene el nombre de usuario, el nombre real, la informaci\u00f3n de identificaci\u00f3n y la informaci\u00f3n b\u00e1sica de la cuenta de cada usuario. Cada l\u00ednea del archivo contiene un registro de base de datos; los campos de registro est\u00e1n separados por dos puntos (:). Puedes usar el gato comando para mostrar el archivo / etc / passwd de su sistema. Aqu\u00ed hay algunas l\u00edneas de muestra de un archivo t\u00edpico: root:x:0:1:System Operator:/:/bin/ksh daemon:x:1:1::/tmp: uucp:x:4:4::/var/spool/uucppublic:/usr/lib/uucp/uucico rocio:x:181:100:Rocio Cordoba:/home/rachel:/bin/ksh arturo:x.:182:100:Arturo Soria:/home/arlin:/bin/csh Las primeras tres cuentas, root , daemon y uucp , son cuentas del sistema, mientras que rachel y arlin son cuentas para usuarios individuales. Los campos individuales del archivo / etc / passwd tienen significados bastante sencillos. La Tabla 4-1 explica una l\u00ednea de muestra del archivo que se muestra arriba. Alguno de los campos m\u00e1s importantes del archivo /etc/passwd, son: Campo Contenido Raquel Nombre de usuario. x Lugar de espera para la \"contrase\u00f1a cifrada\" del usuario. Tradicionalmente, este campo almacenaba la contrase\u00f1a cifrada del usuario. Los sistemas Unix modernos almacenan contrase\u00f1as cifradas en un archivo separado (el archivo de contrase\u00f1as ocultas ) al que solo pueden acceder los usuarios privilegiados. 181 N\u00famero de identificaci\u00f3n de usuario (UID) del usuario. 100 N\u00famero de identificaci\u00f3n de grupo del usuario (GID). Rocio Cordoba Nombre completo del usuario /home/rocio Directorio de inicio del usuario. /bin/ksh Shell del usuario. Las contrase\u00f1as se almacenaban tradicionalmente en el archivo /etc/passwd en un formato cifrado. Sin embargo, debido a los avances en la velocidad del procesador, las contrase\u00f1as cifradas ahora se almacenan casi universalmente en un archivo independiente, llamado /etc/shadow , que se describe m\u00e1s adelante.","title":"El archivo /etc/passwd"},{"location":"section/EntLinux/#el-sistema-de-contrasenas-cifradas-en-unixlinux","text":"Cuando Unix/Linux solicita su contrase\u00f1a, necesita alguna forma de determinar que la contrase\u00f1a es correcta. Muchos de los primeros sistemas inform\u00e1ticos almacenaban las contrase\u00f1as de todas sus cuentas en texto plano en un archivo. En circunstancias normales, el sistema proteg\u00eda las contrase\u00f1as de modo que solo los usuarios privilegiados y las utilidades del sistema operativo pudieran acceder a ellas. Sin embargo, bien por accidente, bien por un error de programaci\u00f3n o por un acto deliberado, un usuario no privilegiado podr\u00eda acceder al contenido de este archivo. Para muestra un bot\u00f3n: Una de las situaciones m\u00e1s memorables ocurri\u00f3 a principios de la d\u00e9cada de 1960 cuando un administrador del sistema en el sistema CTSS del MIT estaba editando el archivo de contrase\u00f1as y otro administrador del sistema estaba editando el mensaje diario que se imprime en el terminal de todos al iniciar sesi\u00f3n. Debido a un error de dise\u00f1o del software, los archivos temporales del editor de los dos usuarios se intercambiaron y, por lo tanto, durante un tiempo, el archivo de contrase\u00f1a se imprimi\u00f3 en cada terminal cuando se iniciaba sesi\u00f3n. El peligro real que planteaban estos sistemas es que los usuarios pueden hacer copias del archivo de contrase\u00f1as y robarlas sin el conocimiento del administrador del sistema. Unix/Linux evitan este problema al no mantener las contrase\u00f1as reales en ninguna parte del sistema. En su lugar, Unix/Linux almacenan un valor que es generado mediante el uso de la contrase\u00f1a para cifrar un bloque de bits con una funci\u00f3n unidireccional llamada crypt(); el resultado del c\u00e1lculo se almacenaba tradicionalmente en /etc/passwd. Cuando se intenta iniciar sesi\u00f3n, el programa /bin/login no descifra la contrase\u00f1a almacenada. En su lugar, /bin/login toma la contrase\u00f1a que ingres\u00f3, la usa para transformar otro bloque de ceros y compara el bloque reci\u00e9n transformado con el bloque almacenado en el archivo /etc/passwd. Si los dos resultados cirfrados coinciden, el sistema lo deja entrar.","title":"El sistema de contrase\u00f1as cifradas en Unix/Linux"},{"location":"section/EntLinux/#la-funcion-de-cifrado-tradicional-crypt","text":"El algoritmo que usa crypt() tradicionalmente se basa en el Est\u00e1ndar de cifrado de datos (DES) del Instituto Nacional de Est\u00e1ndares y Tecnolog\u00eda (NIST). En funcionamiento normal, DES utiliza una clave de 56 bits (8 caracteres ASCII de 7 bits, por ejemplo) para cifrar bloques de texto original o texto sin cifrar, que resultaban tener 64 bits de longitud. Los bloques de 64 bits resultantes de texto cifrado o texto cifrado no se pueden descifrar f\u00e1cilmente al texto sin formato original sin conocer la clave original de 56 bits. Actualmente este algoritmo ha sido sustituido por unos mucho m\u00e1s seguros y robustos.","title":"La funci\u00f3n de cifrado tradicional crypt()"},{"location":"section/EntLinux/#echandole-salt","text":"A medida que los ordenadores aumentaban de potencia y los algoritmos de cifrado fueron empezando a considerarse inseguros por ello, se inventaron nuevas formas de fortificarlos. Una de ellas fue el elemento conocido como \"salt\". En criptograf\u00eda, la sal (en ingl\u00e9s, salt) comprende bits aleatorios que se usan como una de las entradas en una funci\u00f3n derivadora de claves. La otra entrada es habitualmente una contrase\u00f1a. La salida de la funci\u00f3n derivadora de claves se almacena como la versi\u00f3n cifrada de la contrase\u00f1a. En definitiva, el salt es una cadena de caracteres aleatorios que se concatenan con la contrase\u00f1a antes de cifrarla para dificultad en gran medida su descifrado por un atacante. Los datos con sal complican los ataques de diccionario que cifran cada una de las entradas del mismo: cada bit de sal duplica la cantidad de almacenamiento y computaci\u00f3n requeridas. Para mayor seguridad, el valor de sal se guarda en secreto, separado de la base de datos de contrase\u00f1as. Esto aporta una gran ventaja cuando la base de datos es robada, pero la sal no. El beneficio aportado por usar una contrase\u00f1a con sal es que un ataque simple de diccionario contra los valores cifrados es impracticable si la sal es lo suficientemente larga. As\u00ed el formato del contenido del archivo /etc/shadow es: El campo a la derecha del nombre de usuario indica qu\u00e9 algoritmo se ha utilizado para cifrar la contrase\u00f1a junto con el salt del tercer campo. Por curiosidad, algunos de estos algorimos son: Valor Algoritmo $1$ MD5 $2a$ Blowfish $2y$ Blowfish $5$ SHA-256 $6$ SHA-512 Los signos del d\u00f3lar delimitan estos dos campos.","title":"Ech\u00e1ndole \"salt\""},{"location":"section/EntLinux/#principales-comandos-para-manejarse-en-el-terminal","text":"","title":"Principales comandos para manejarse en el terminal"},{"location":"section/EntLinux/#crear-archivos-y-directorios","text":"A modo de tutorial, puede ser interesante seguir los comandos que aqu\u00ed se muestran. Para ello, en primer lugar vamos a crear un subdirectorio dentro del directorio /tmp y nos ubicaremos dentro de ese subdirectorio: mkdir /tmp/tutorial cd /tmp/tutorial El comando mkdir es una abreviatura de \"make directory\" y se utiliza para crear nuevos directorios vac\u00edos. Permite incluso crear varios directorios en un s\u00f3lo comando utilizando el n\u00famero de par\u00e1metros o argumentos adecuado: mkdir dir1 dir2 dir3 Si quisi\u00e9ramos listar los directorios creados, podr\u00edamos utilizar el comando para ello: ls Podr\u00edamos incluso darle una vuleta de tuerca al comando. Ya que los directorios que crea est\u00e1n vac\u00edos, pero si quisi\u00e9ramos crear una carpeta con subdirectorios en su interior utilizando un \u00fanico comando, har\u00edamos: mkdir -p dir4/dir5/dir6 ls El \"-p\" es lo que se conoce como un switch , que no son m\u00e1s que distintas opciones para modificar el comportamiento de un comando. Y podr\u00edamos movernos por los subdirectorios para comprobar que, efectivamente, se han creado: cd dir4 ls cd dir5 ls cd ../.. Ahora que ya sabemos c\u00f3mo crear varios directorios simplemente pas\u00e1ndolos como argumentos separados al mkdircomando. Pero supongamos que queremos crear un directorio con un espacio en el nombre. Vamos a intentarlo: mkdir otro directorio ls Pod\u00e9is intentar escribir esto en el terminal o, si s\u00f3is un poco suspicaces, os habr\u00e9is dado cuenta de lo que pasar\u00e1. Exactamente, se crearan dos directorios distintos. Si queremos trabajar con espacios en nombres de archivos o directorios, necesitamos \"escaparlos\" . \u00c9ste es un termino inform\u00e1tico que hace referencia a c\u00f3digos especiales para decirle a la m\u00e1quina que determinados caracteres y s\u00edmbolos los trate de forma diferente a lo normal. Como ejemplo: mkdir \"carpeta 1\" mkdir 'carpeta 2' mkdir carpeta \\ 3 mkdir \"carpeta 4\" \"carpeta 5\" mkdir -p \"carpeta 6\" / \"carpeta 7\" ls Todos estos comandos crear\u00e1n carpetas independientes y con espacios en los nombres. Debido a lo engorroso de tener que escapar este tipo de caracteres cada vez que se utilizan en el terminal, la tendencia es usar nombres sin espacios, sustituyendo estos por guiones (\"-\") o guiones bajos (\"_\")","title":"Crear archivos y directorios"},{"location":"section/EntLinux/#creando-archivos-usando-la-redireccion","text":"Supongamos que quisi\u00e9ramos capturar la salida del comando \"ls\" como un archivo de texto que podemos manipular con posterioridad. Todo lo que tenemos que hacer es agregar el car\u00e1cter mayor que (\u201d>\u201d) al final de nuestra l\u00ednea de comando, seguido del nombre del archivo en el que escribir: ls > salida.txt No se imprimir\u00e1 nada por pantalla puesto que hemos redirigido la salida del comando al archivo salida.txt. En todo caso, podemos utilizar el comando \"cat\" para ver el contenido del archivo: cat output.txt Otro ejemplo de redirecci\u00f3n podr\u00edamos llevarlo a cabo utilizando el comando \"echo\", el cual simplemente imprime por pantalla los argumentos que recibe. Sin embargo, podr\u00edamos redirigir la salida a un archivo y crear ficheros nuevos: echo \"Esto es una prueba\" > test_1.txt echo \"Esto es otra prueba\" > test_2.txt echo \"Otra prueba m\u00e1s\" > test_3.txt ls Y para ver el contenido de los archivos podemos utilizar nuevamente \"cat\". Incluso podr\u00edamos pasarle el nombre de los 3 archivos simult\u00e1nemamente como argumentos: cat test_1.txt test_2.txt test_3.txt Cuando desee pasar varios nombres de archivo a un solo comando, existen algunos atajos \u00fatiles que pueden ahorrarle mucho escribir si los archivos tienen nombres similares. Se puede utilizar un signo de interrogaci\u00f3n (\"?\") Para indicar \"cualquier car\u00e1cter\" dentro del nombre del archivo. Se puede utilizar un asterisco (\u201d*\u201d) para indicar \u201ccero o m\u00e1s caracteres\u201d. A veces se los denomina caracteres \"comod\u00edn\". Un par de ejemplos pueden ayudar, los siguientes comandos hacen lo mismo: cat test_1.txt test_2.txt test_3.txt cat test_?.txt cat test_* Atenci\u00f3n Precisamente por las car\u00e1cteres comod\u00edn en los comandos, tampoco es recomendable usar signos de puntuaci\u00f3n en los nombres de los archivos, de otra forma habr\u00eda que \"escapar\" estos caracteres a la hora de trabajar en la l\u00ednea de comandos con los nombres de los archivos Observando la salida de ls , se puede ver que los \u00fanicos archivos o carpetas que comienzan por \"t\" son los tres archivos de prueba que acabamos de crear, por lo que incluso se podr\u00eda simplificar ese \u00faltimo comando a\u00fan m\u00e1s cat t* , lo que significa \"concatenar todos los archivos cuyos nombres comienzan con una t y van seguidos de cero o m\u00e1s caracteres \u201d. Usemos esta capacidad para unir todos nuestros archivos en un solo archivo nuevo y luego verlo: cat t* > combinado.txt cat combinado.txt Hay que tener cuidado puesto que la shell borra todo el contenido del archivo antes de escribir la salida del comando cat en \u00e9l. Debido a esto, debe tener mucha precauci\u00f3n al usar la redirecci\u00f3n para asegurarse de no sobrescribir accidentalmente un archivo que necesita. Si lo que queremos es a\u00f1adir al final del archivo en lugar de reemplazar el contenido del mismo, debemos poner un doble s\u00edmbolo de \"mayor que\": cat t* >> combinado.txt echo \"\u00a1He a\u00f1adido una l\u00ednea!\" >> combinado.txt cat combinado.txt Cuando el contenido del archivo es mayor de lo que se puede mostrar en la terminal, se necesita utilizar lo que se conoce como pager para que pagine la salida por el terminal. El pager m\u00e1s antiguo era more porque colocaba una l\u00ednea de texto que dec\u00eda \"--More--\" para indicar que a\u00fan hab\u00eda contenido por mostrar. Posteriormente surgi\u00f3 el pager less con el fin de reemplazar a more . less archivo_muy_largo.txt Al examinar un archivo utilizando less , se pueden utilizar las teclas de flecha arriba, flecha abajo, Re P\u00e1g, Av P\u00e1g, Inicio y Fin para desplazarse a trav\u00e9s del fichero.","title":"Creando archivos usando la redirecci\u00f3n"},{"location":"section/EntLinux/#a-proposito-de-las-mayusculas-y-minusculas","text":"Los sistemas Unix son \"case sensitive\", es decir, distinguen entre may\u00fasculas y min\u00fasculas, es decir, consideran que \u201cA.txt\u201d y \u201ca.txt\u201d son dos archivos diferentes. Ejecutando los siguientes comandos se terminar\u00eda con tres archivos distintos: echo \"Con minusculas\" > a.txt echo \"Con mayusculas\" > A.TXT echo \"Ambas mezcladas\" > A.txt Se debe tener precauci\u00f3n con esto puesto que Windows es \"case insensitive\" y no distinguir\u00eda entre esos tres archivos, los tratar\u00eda como uno solo. Buenas pr\u00e1cticas de nomenclatura Cuando se considera tanto la distinci\u00f3n entre may\u00fasculas y min\u00fasculas como el escape, una buena regla general es mantener los nombres de los archivos en min\u00fasculas, con solo letras, n\u00fameros, guiones bajos y guiones. Adem\u00e1s, aunque en linux los archivos no tienen extensi\u00f3n, se la pondremos con el fin de facilitar el trabajo.","title":"A prop\u00f3sito de las may\u00fasculas y min\u00fasculas"},{"location":"section/EntLinux/#moviendo-y-manipulando-archivos","text":"Ahora que ya hemos aprendido a crear archivos, vemos que tareas comunes podemos realizar con ellos. Por ejemplo, si queremos mover nuestro archivo combinado.txt al directorio dir1 , usando el comando mv (move) : mv combinado.txt dir1 Para confirmar que el comando se ha ejecutado con \u00e9xito podemos utilizar el comando ls para ver que el fichero ya no est\u00e1 en el directorio de trabajo, luego con cd dir1 cambiar a ese directorio, hacer ls para ver que ahora el fichero est\u00e1 all\u00ed, y luego cd .. para movernos al directorio de trabajo nuevamente. Los dos puntos nos permiten indicarle a un comando el directorio inmediatamente superior al que estamos. O tambi\u00e9n podemos ahorrarnos la mayor parte de este trabajo de escritura pasando una ruta directamente al comando ls consultar directamente el contenido de ese directorio: ls dir1 Si ahora quisi\u00e9ramos devolver el archivo combinado.txt al directorio padre, tendr\u00edamos dos opciones: Entrar en dir1 con cd y usar mv combinado.txt .. . De la misma manera que dos puntos ( ..) representan el directorio padre, por lo que .se puede usar un solo punto ( ) para representar el directorio de trabajo actual Como sabemos que solo hay un archivo en dir1 , podemos usar \u201c*\u201d para que coincida con cualquier nombre de archivo en ese directorio, ahorr\u00e1ndonos escribir m\u00e1s comandos. Nuestro comando para mover el archivo de nuevo al directorio de trabajo se convierte en esto (se debe tener en cuenta el espacio antes del punto, ya que hay dos par\u00e1metros que se pasan a mv ): mv dir1/* . El comando mv nos permite mover m\u00e1s de un fichero a la vez. Si se le pasa m\u00e1s de dos argumentos, el \u00faltimo se toma como el directorio de destino y los otros se consideran archivos (o directorios) a mover: mv combinado.txt test_* dir3 dir2 ls ls dir2 Si quisi\u00e9ramos mover una vez m\u00e1s el archivo combinado.txt a un directorio llamado dir6, que estar\u00e1 dentro del directorio dir5, que a su vez est\u00e1 dentro del directorio dir4 y todos ellos dentro de nuestro directorio de trabajo, har\u00edamos: mv dir2/combinado.txt dir4/dir5/dir6 ls dir2 ls dir4/dir5/dir6 Es decir, indicando las rutas adecuadas de directorios, podremos ejecutar este tipo de comandos desde cualquier lugar en el sistema de archivos o directorios. Si ahora lo que quisi\u00e9ramos fuera hacer una copia del archivo combinado.txt en nuestro directorio de trabajo, podr\u00edamos hacer dicha copia y comprobarla con la siguiente secuencia de comandos: cp dir4/dir5/dir6/combinado.txt . ls dir4/dir5/dir6 ls Si adem\u00e1s nos vi\u00e9ramos en la necesidad de cambiarle el nombre a un archivo o carpeta, Unix interpreta este hecho como que se est\u00e1 moviendo un archivo a otro, por ello haremos uso de mv , como por ejemplo: mv backup_combinado.txt combinado_backup.txt ls De la misma forma, mv nos permite renombrar directorios: mv \"carpeta 1\" carpeta_1 mv \"carpeta 2\" carpeta_2 mv \"carpeta 3\" carpeta_3 mv \"carpeta 4\" carpeta_4 mv \"carpeta 5\" carpeta_5 mv \"carpeta 6\" carpeta_6 ls","title":"Moviendo y manipulando archivos"},{"location":"section/EntLinux/#eliminar-archivos-y-carpetas","text":"Ahora que ya sabemos c\u00f3mo mover, copiar y renombrar archivos y directorios, \u00fanicamente nos queda saber c\u00f3mo eliminarlos. Para ello usamos el comando rm (remove): rm dir4/dir5/dir6/combinado.txt Adem\u00e1s de archivos, se podr\u00eda intentar eliminar directorios que no hagan falta, como por ejemplo: \u00a1Wow! \u00bfA qu\u00e9 se debe ese error? Pues que por motivos de seguridad o precauci\u00f3n, a pesar de que rm permite elminar miles de archivos con un \u00fanico comando, no permite eliminar un directorio completo. Para ello necesitaremos el comando rmdir : A pesar que las carpetas de la 1 a la 5 se han eliminado, las 6 nos ha dado un error. Esto es porque el comando mkdir , una vez m\u00e1s por motivos de precacuci\u00f3n, exige que la carpeta est\u00e9 vac\u00eda para eliminarla. No obstante, la tarea m\u00e1s habitual cuando realmente se est\u00e1 seguro de que se desea eliminar un directorio y todo lo que contiene, es utilizar el comando rm de forma recursiva, usando el switch u opci\u00f3n -r : Recordatorio : aunque rm -r es r\u00e1pido y eficaz, tambi\u00e9n es peligroso. Es m\u00e1s seguro eliminar archivos expl\u00edcitamente para borrar un directorio, luego cd .. al padre antes de usar rmdir para eliminarlo. \u00a1Peligro! A diferencia de las interfaces gr\u00e1ficas, rm no mueve archivos a ninguna carpeta llamada \"papelera\" o similar. En cambio, los elimina total e irrevocablemente. Se debe tener mucho cuidado con los par\u00e1metros que usa con rm para asegurarno de que solo est\u00e1n eliminando los archivos deseados. Y se debe tener especial cuidado al usar comodines, ya que es f\u00e1cil eliminar accidentalmente m\u00e1s archivos de los que se pretend\u00eda. Un car\u00e1cter \"espacio\" equivocado en el comando puede cambiarlo por completo: rm t* significa \"eliminar todos los archivos que comienzan con t\", mientras que rm t * significa \"eliminar el archivo t as\u00ed como cualquier archivo cuyo nombre conste de cero o m\u00e1s caracteres, que ser\u00eda todo en el \u00a1directorio! Si no se est\u00e1 seguro, se puede usar la opci\u00f3n -i(interactive opcional) del rm que pedir\u00e1 que se confirme la eliminaci\u00f3n de cada archivo.","title":"Eliminar archivos y carpetas"},{"location":"section/EntLinux/#un-poco-de-fontaneria-tuberias","text":"A pesar de todos los avances t\u00e9cnicos de las \u00faltimas d\u00e9cadas, el texto sigue jugando un papel fundamental en la inform\u00e1tica. La suerte es que en Linux existen m\u00faltiples herramientas excepcionales para el manejo de texto. Comenzando con algo simple, \u00bfc\u00f3mo podr\u00edamos contar las l\u00edneas del archivo combinado.txt? Simple, con el comando wc (word count) , usando la opci\u00f3n -l con el fin de indicarle que \u00fanicamente queremos contar l\u00edneas: wc -l combinado.txt De manera similar, si quisi\u00e9ramos saber cu\u00e1ntos archivos y carpetas hay en nuestro directorio home (~) y contarlos, podr\u00edamos hacer lo siguiente: ls ~ | wc -l Esto es lo que se conoce como un pipe o tuber\u00eda. La l\u00ednea de comandos de Unix permite tomar la salida de un comando y con ella alimentar la entrada del siguiente comando. Esto es lo que conoce como canalizar los datos de un comando a otro y para ello se utiliza el car\u00e1cter \"|\" . Los espacios alrededor del car\u00e1cter de tuber\u00eda no tienen importancia, este comando por ejemplo funcionar\u00eda perfectamente: ls /etc | wc -l \u00a1Uf! Son bastantes archivos. Si quisi\u00e9ramos enumerarlos todos, claramente llenar\u00eda m\u00e1s de una pantalla. Como ya hemos visto anteriormente, cuando un comando produce una gran cantidad de resultados, es mejor usar less para verlo, y ese consejo a\u00fan se aplica cuando se usa una tuber\u00eda (recordad, presionad q para salir): ls /etc | less Una vuelta de tuerca m\u00e1s ser\u00eda saber cu\u00e1ntas l\u00edneas sin repetir tiene el archivo combinado.txt , es decir, cu\u00e1ntas l\u00edneas son sin contar las repetidas. El comando que nos permite hacer esto en Unix es uniq : Parece que se est\u00e1n eliminando muy pocas, si es que hay alguna, de nuestras l\u00edneas duplicadas. Para entender por qu\u00e9, necesitamos mirar la documentaci\u00f3n del comando. La mayor\u00eda de las herramientas de l\u00ednea de comandos vienen con un breve (y a veces no tan breve) manual de instrucciones, se accede a trav\u00e9s del comando man . La salida se canaliza autom\u00e1ticamente a trav\u00e9s del paginador less , por lo que podremos movernos hacia adelante y hacia atr\u00e1s,presionando finalmente \"q\" cuando queramos salir: man uniq El formato de las p\u00e1ginas de manual es a menudo conciso, se debe pensar en ellas m\u00e1s como una descripci\u00f3n general r\u00e1pida de un comando que como un tutorial completo. A menudo son muy t\u00e9cnicas, pero generalmente se puede omitir la mayor parte del contenido y simplemente buscar los detalles de la opci\u00f3n o el argumento en el que estamos interesados. La p\u00e1gina de manual de uniq es un ejemplo t\u00edpico, ya que comienza con una breve descripci\u00f3n de una l\u00ednea del comando, pasa a una sinopsis de c\u00f3mo usarlo y luego tiene una descripci\u00f3n detallada de cada opci\u00f3n o par\u00e1metro. Pero aunque las p\u00e1ginas de manual son invaluables, tambi\u00e9n pueden ser impenetrables. Se han de utilizar mejor cuando se necesita un recordatorio de un interruptor/switch/opci\u00f3n o par\u00e1metro en particular, en lugar de como un recurso general para aprender a usar la l\u00ednea de comandos. Sin embargo, la primera l\u00ednea de la secci\u00f3n DESCRIPCI\u00d3N responde a la pregunta de por qu\u00e9 no se han eliminado las l\u00edneas duplicadas: solo funciona en l\u00edneas coincidentes adyacentes. La pregunta, entonces, es c\u00f3mo reorganizar las l\u00edneas en nuestro archivo para que las entradas duplicadas est\u00e9n en l\u00edneas adyacentes. Si tuvi\u00e9ramos que ordenar el contenido del archivo alfab\u00e9ticamente, eso ser\u00eda suficiente. Unix ofrece un comando para hacer exactamente eso, sort . Una revisi\u00f3n r\u00e1pida del man muestra que podemos pasar un nombre de archivo directamente al comando, as\u00ed que veamos qu\u00e9 le hace a nuestro archivo: sort combinado.txt | less Deber\u00edis poder ver que las l\u00edneas se han reordenado y ahora se han adecuado para conectarlas directamente con uniq . Finalmente podemos completar nuestra tarea de contar las l\u00edneas \u00fanicas en el archivo: sort combinado.txt | uniq | wc -l Como se puede ver, la capacidad de canalizar datos de un comando a otro, creando largas cadenas para manipular sus datos, es una herramienta poderosa. Por esta raz\u00f3n, ver\u00e9is que se usan con bastante frecuencia en las l\u00ednea de comandos. Una cadena larga de comandos puede parecer intimidante al principio, pero recordad que se puede dividir incluso la cadena m\u00e1s larga en comandos individuales (y mirar sus p\u00e1ginas de manual) para comprender mejor lo que est\u00e1 haciendo.","title":"Un poco de fontaner\u00eda (tuber\u00edas)"},{"location":"section/EntLinux/#la-linea-de-comandos-y-el-superusuario","text":"El superusuario es, como su nombre indica, un usuario con superpoderes. En los sistemas m\u00e1s antiguos, era un usuario real, con un nombre de usuario real (casi siempre \u201croot\u201d) que pod\u00eda iniciar sesi\u00f3n como si tuviera la contrase\u00f1a. En cuanto a esos superpoderes: root puede modificar o eliminar cualquier archivo en cualquier directorio del sistema, independientemente de qui\u00e9n sea el propietario; root puede reescribir las reglas del firewall o iniciar servicios de red que potencialmente podr\u00edan abrir la m\u00e1quina a un ataque; root puede apagar la m\u00e1quina incluso si otras personas todav\u00eda la est\u00e1n usando. En resumen, root puede hacer casi cualquier cosa, saltando f\u00e1cilmente las salvaguardas que generalmente se implementan para evitar que los usuarios sobrepasen sus l\u00edmites. Por supuesto, una persona que haya iniciado sesi\u00f3n como root es tan capaz de cometer errores como cualquier otra persona. Los anales de la historia de la inform\u00e1tica est\u00e1n llenos de historias de un comando mal escrito que borr\u00f3 todo un sistema de archivos o que acab\u00f3 con un servidor esencial. Adem\u00e1s existe la posibilidad de un ataque malicioso: si un usuario inicia sesi\u00f3n como root y abandona su escritorio, no es demasiado complicado para un colega descontento saltar a su m\u00e1quina y causar estragos. En un esfuerzo por reducir estos problemas, muchas distribuciones de Linux comenzaron a fomentar el uso del comando su . Es la abreviatura de 'superuser' y nos permite cambiar a otro usuario de la m\u00e1quina sin tener que hacer logout y login de nuevo. Cuando se usa sin argumentos, asume que se desea cambiar al usuario root, pero puede pasarle un nombre de usuario para cambiar a una cuenta de usuario espec\u00edfica. Fomentando el uso de su el objetivo era persuadir a los administradores para que pasaran la mayor parte de su tiempo usando una cuenta normal, que s\u00f3lo cambiaran a la cuenta de superusuario cuando lo necesitaran y luego usaran el comando logout (o el atajo Ctrl-D ) tan pronto como fuera posible para regresar a su usuario normal. Al minimizar la cantidad de tiempo que se pasa conectado como root , el uso de su reduce la ventana de oportunidad para cometer un error catastr\u00f3fico. A pesar de eso, siendo la naturaleza humana lo que es, muchos administradores han sido culpables de dejar abiertos terminales de larga duraci\u00f3n en los que sol\u00edan hacer su para cambiar a la cuenta de root. En ese sentido, sufue solo un peque\u00f1o paso adelante en materia de seguridad. Cuando se utiliza su toda la sesi\u00f3n del terminal se cambia al otro usuario. Los comandos que no necesitan acceso de root, algo tan mundano como pwd o `ls , se ejecutar\u00edan bajo los auspicios y permisos del superusuario, aumentando el riesgo de que un error en el programa cause problemas importantes. Peor a\u00fan, si pierde la pista de qu\u00e9 usuario est\u00e1 actuando en cada momento, se puede eejecutar un comando que fuera bastante benigno cuando se ejecuta como usuario, pero que podr\u00eda destruir todo el sistema si se ejecuta como root . Es mejor deshabilitar la cuenta de root por completo y luego, en lugar de permitir sesiones de terminal de larga duraci\u00f3n con poderes peligrosos, requerir que el usuario solicite espec\u00edficamente derechos de superusuario por comando. La clave de este enfoque es un comando llamado sudo ( \u201c s witch u ser and do this command\u201d). sudo se utiliza para preceder a un comando que debe ejecutarse con privilegios de superusuario. Se utiliza un archivo de configuraci\u00f3n para definir qu\u00e9 usuarios pueden usar sudo y qu\u00e9 comandos pueden ejecutar. Cuando se ejecuta un comando como este, se le solicita al usuario su propia contrase\u00f1a, que luego se almacena en cach\u00e9 durante un per\u00edodo de tiempo (por defecto es de 15 minutos), por lo que si necesita ejecutar varios comandos de nivel de superusuario, no se le siguen pidiendo cada vez. Un ejemplo de todo lo comentado hasta ahora, ser\u00eda: \u00a1Cuidado con sudo! Si se indica que debe ejecutarse un comando con sudo , asegur\u00e1os de comprender lo que hace el comando antes de continuar. Ejecutar con sudo le da a ese comando los mismos poderes que un superusuario.","title":"La l\u00ednea de comandos y el superusuario"},{"location":"section/EntLinux/#archivos-ocultos","text":"Este tipo de archivos se usan com\u00fanmente en sistemas Linux para almacenar configuraciones y/o datos de configuraci\u00f3n y generalmente se ocultan simplemente para que no abarroten la vista de sus propios archivos. No hay nada especial en un archivo o carpeta ocultos, aparte de su nombre: simplemente comenzar un nombre con un punto (\u201d.\u201d) Es suficiente para que desaparezca. cd /tmp/tutorial ls mv combinado.txt .combinado.txt ls A\u00fan se puede trabajar con el archivo oculto asegur\u00e1ndose de incluir el punto cuando especifique su nombre de archivo: cat .combinado.txt mkdir .oculto mv .combinado.txt .oculto less .oculto/.combined.txt Si se ejecuta ls , se ver\u00e1 que el directorio .oculto est\u00e1, como era de esperar, oculto. A\u00fan se puede enumerar su contenido usando ls .hidden , pero como s\u00f3lo contiene un solo archivo que est\u00e1, as\u00edmismo, oculto, no se obtendr\u00e1n muchos resultados. Sin embargo, se puede utilizar la opci\u00f3n/switch -a del comando `ls para hacer que se muestre todo en un directorio, incluyendo los archivos y carpetas ocultos: ls ls -a ls .hidden ls -a .hidden Estos archivos normalmente almacenan la configuraci\u00f3n personal, y es as\u00ed como los sistemas Unix siempre han ofrecido la capacidad de tener configuraciones a nivel de sistema (generalmente en /etc) que pueden ser anuladas por usuarios individuales (cortes\u00eda de archivos ocultos en su directorio de inicio).","title":"Archivos ocultos"},{"location":"section/EntWin/","text":"Entornos Windows Active Directory Empresas de todos los tama\u00f1os en todo el mundo utilizan Active Directory para administrar los permisos y controlar el acceso a los recursos cr\u00edticos de la red empresarial. Pero, \u00bfqu\u00e9 es exactamente y c\u00f3mo afecta al negocio? \u00bfQu\u00e9 es Active Directory? Active Directory (AD) es un servicio de directorio que se ejecuta en Microsoft Windows Server. Un directorio es una estructura jer\u00e1rquica que almacena informaci\u00f3n sobre los objetos en la red. La funci\u00f3n principal de Active Directory es permitir que los administradores del sistema manejen permisos y controlen el acceso a los recursos de la red. En Active Directory, los datos se almacenan como objetos, que incluyen usuarios, grupos, aplicaciones, servicios o dispositivos, y estos objetos se clasifican seg\u00fan su nombre y atributos. Active Directory usa un almac\u00e9n de datos estructurado como base para una organizaci\u00f3n jer\u00e1rquica l\u00f3gica de la informaci\u00f3n del directorio. Definici\u00f3n El directorio activo o Active Directory (AD) es una manera de organizar y gestionar todos los elementos de una red inform\u00e1tica: ordenadores, grupos, usuarios, dominios, pol\u00edticas de seguridad, y cualquier tipo de objetos definidos para el usuario. AD simplifica la vida de los administradores y usuarios finales al tiempo que mejora la seguridad de las organizaciones a trav\u00e9s de la funci\u00f3n pol\u00edticas de grupo de AD. Los usuarios pueden autenticarse una vez y luego acceder sin problemas a cualquier recurso en el dominio para el que est\u00e1n autorizados (inicio de sesi\u00f3n \u00fanico). Adem\u00e1s, los archivos se almacenan en un repositorio central donde se pueden compartir con otros usuarios para facilitar la colaboraci\u00f3n y los equipos de TI pueden respaldarlos adecuadamente para garantizar la continuidad del negocio. Antes de nada, \u00bfqu\u00e9 es un dominio? Un dominio representa una agrupaci\u00f3n l\u00f3gica de un conjunto ordenadores conectados en una red los cuales comparten una base de datos de Active Directory. La base de base de datos es probablemente el elemento m\u00e1s importante en un AD (Active Directory) y es gestionada por los servidores centrales del dominio, tambi\u00e9n conocidos como Domain Controllers. Un dominio b\u00e1sicamente es una etiqueta que t\u00edpicamente representa un nombre DNS, el cual en algunas organizaciones es el mismo que su sitio web, pero no tiene porque ser as\u00ed en todos los casos y es posible que la organizaci\u00f3n prefiera utilizar otro nombre de dominio que ser\u00e1 al que se unir\u00e1n las estaciones de trabajo. \u00bfQu\u00e9 son los Domain Services (sevicios de dominio) de Active Directory? Los servicios de dominio de Active Directory (AD DS) son un componente central de Active Directory y proporcionan el mecanismo principal para autenticar a los usuarios y determinar a qu\u00e9 recursos de red pueden acceder. Los servidores que ejecutan AD DS se denominan controladores de dominio (DC). \u00c9stos son sistemas basados en Windows Server que pueden acceder y manipular la base de datos del AD. Cada dominio tiene como m\u00ednimo un controlador, por lo que si por ejemplo, un departamento o unidad de negocio crece m\u00e1s de lo esperado, es posible instalar m\u00e1s controladores de dominio dedicados a procesar las solicitudes de las estaciones de trabajo en ese departamento. Tambi\u00e9n es posible crear subdominios para que los usuarios puedan acceder a los recursos en otros subdominios que hagan parte del mismo Forest. Las organizaciones normalmente tienen varios DC y cada uno tiene una copia del directorio para todo el dominio. Los cambios realizados en el directorio en un controlador de dominio, como la actualizaci\u00f3n de la contrase\u00f1a o la eliminaci\u00f3n de una cuenta de usuario, se replican en los otros controladores de dominio para que todos est\u00e9n actualizados. AD DS tambi\u00e9n proporciona caracter\u00edsticas adicionales como inicio de sesi\u00f3n \u00fanico (SSO) mediante Kerberos, certificados de seguridad, LDAP (protocolo ligero de acceso a directorios) y administraci\u00f3n de derechos de acceso. La estructura jer\u00e1rquica de los servicios de dominio de Active Directory Los dominios en AD son muy flexibles y permiten crear una infraestructura completa y bien organizada. Partiendo de un dominio ra\u00edz, es posible crear subdominios que representen la disposici\u00f3n f\u00edsica y/o l\u00f3gica de las estaciones de trabajo. Esto significa que se puede crear un subdominio para el departamento de ventas, IT, marketing, etc. Tambi\u00e9n se podr\u00eda crear subdominios para las oficinas que se encuentran distribuidas en diferentes ubicaciones geogr\u00e1ficas. Evidentemente, se trata de decisiones de dise\u00f1o a la hora de configurar la red. AD DS organiza los datos en una estructura jer\u00e1rquica que consta de dominios, \u00e1rboles y bosques, como se detalla a continuaci\u00f3n. Dominios: un dominio representa un grupo de objetos, como usuarios, grupos y dispositivos, que comparten la misma base de datos de AD. Puedes pensar en un dominio como una rama en un \u00e1rbol. Un dominio tiene la misma estructura que los dominios y subdominios est\u00e1ndar, por ejemplo, tudominio.com y ventas.tudominio.com. Un dominio representa un l\u00edmite de administraci\u00f3n. Los objetos de un dominio determinado se almacenan en una \u00fanica base de datos y se pueden administrar juntos. \u00c1rboles: un \u00e1rbol es uno o m\u00e1s dominios agrupados en una jerarqu\u00eda l\u00f3gica. Dado que los dominios de un \u00e1rbol est\u00e1n relacionados, se dice que \"conf\u00edan\" entre s\u00ed. Bosque: un bosque es el nivel m\u00e1s alto de organizaci\u00f3n dentro de AD y contiene un grupo de \u00e1rboles. Los \u00e1rboles de un bosque tambi\u00e9n pueden confiar entre s\u00ed y tambi\u00e9n compartir\u00e1n esquemas de directorio, cat\u00e1logos, informaci\u00f3n de aplicaciones y configuraciones de dominio. Un bosque representa un l\u00edmite de seguridad. Los objetos de diferentes bosques no pueden interactuar entre s\u00ed a menos que los administradores de cada bosque creen una relaci\u00f3n de confianza entre ellos Unidades organizativas: una unidad organizativa permite, como su propio nombre indica, organizar y agrupar usuarios, grupos, equipos y otras unidades organizativas. Las unidades organizativas (OU) de un dominio administrado de Active Directory Domain Services (AD DS) permiten agrupar l\u00f3gicamente objetos como cuentas de usuario, cuentas de servicio o cuentas de equipo. Despu\u00e9s, se puede asignar administradores a unidades organizativas espec\u00edficas y aplicar la directiva de grupo para aplicar los valores de configuraci\u00f3n de destino. Contenedores: un contenedor es similar a una unidad organizativa; sin embargo, a diferencia de una unidad organizativa, no es posible vincular un objeto de directiva de grupo (GPO) a un contenedor gen\u00e9rico de Active Directory. Otros servicios de Active Directory Adem\u00e1s de los servicios de dominio de Active Directory, hay varios otros servicios cr\u00edticos que proporciona AD. Algunos de esos servicios se enumeran a continuaci\u00f3n: Servicios de directorio ligeros: AD LDS es un servicio de directorio del Protocolo ligero de acceso a directorios (LDAP). Proporciona solo un subconjunto de las funciones de AD DS, lo que lo hace m\u00e1s vers\u00e1til en t\u00e9rminos de d\u00f3nde se puede ejecutar. Por ejemplo, se puede ejecutar como un servicio de directorio independiente sin necesidad de integrarse con una implementaci\u00f3n completa de Active Directory. Servicios de certificados: puede crear, administrar y compartir certificados de cifrado, que permiten a los usuarios intercambiar informaci\u00f3n de forma segura a trav\u00e9s de Internet. Servicios de federaci\u00f3n de Active Directory: ADFS es una soluci\u00f3n de inicio de sesi\u00f3n \u00fanico (SSO) para AD que permite a los empleados acceder a m\u00faltiples aplicaciones con un \u00fanico conjunto de credenciales, lo que simplifica la experiencia del usuario. Servicios de administraci\u00f3n de derechos: AD RMS es un conjunto de herramientas que ayuda con la administraci\u00f3n de tecnolog\u00edas de seguridad que ayudar\u00e1n a las organizaciones a mantener sus datos seguros. Dichas tecnolog\u00edas incluyen cifrado, certificados y autenticaci\u00f3n, y cubren una variedad de aplicaciones y tipos de contenido, como correos electr\u00f3nicos y documentos de Word. El servidor que aloja AD DS se denomina controlador de dominio (DC) . Tambi\u00e9n se puede usar un controlador de dominio para autenticarse con otros productos de MS, como Exchange Server, SharePoint Server, SQL Server, File Server u otros. Atenci\u00f3n El controlador de dominio, hablando de ciberseguridad en entornos Windows, es la joya de la corona . Bien sea realizando un pentest legal, bien sea un ataque malintencionado por parte de ciberdelincuentes, el fin \u00faltimo siempre ser\u00e1 llegar a ser administrador del Controlador de Dominio (DC). Por ello es tremendamente importante conocer su complejo funcionamiento y saber fortificarlo en la medida de lo posible para protegernos frente a los ataques m\u00e1s comunes. Usuarios de AD Entre otras cosas, Active Directory gestiona los usuarios del entorno trat\u00e1ndolos como un tipo de objeto especial que se almacena en la base de datos central. A continuaci\u00f3n se listan algunas cuestiones importantes a tener en cuenta sobre los usuarios de un dominio. Aunque el nombre de usuario sirve para identificarle, el SID (Security Identifier) tambi\u00e9n puede ser utilizado para dicho fin. El SID es la combinaci\u00f3n del Domain SID y el RID (Relative Identifier). Algunas herramientas ense\u00f1an el SID en lugar del nombre de usuario, por ese motivo es importante saber esto. Los user secrets son elementos utilizados por el Domain Controller para realizar el proceso de autenticaci\u00f3n. Las contrase\u00f1as no se guardan en texto plano, pero los user secrets derivados de ellas s\u00ed, los cuales son Hashes NT y claves Kerberos. Los hashes LM y NT son almacenados en dos sitios: La SAM (Security Account Manager) de Windows y la base de datos del AD, la cual por defecto se encuentra disponible en los DC en la ruta C:\\Windows\\NTDS\\ntds.dit. Aunque los hashes NT no son contrase\u00f1as, se pueden utilizar en algunos casos para ataques del tipo Pass-The-Hash/Overpass-The-Hash Los ordenadores registrados en un AD tambi\u00e9n est\u00e1n representados por una cuenta de usuario, la cual es el nombre de la estaci\u00f3n de trabajo con un \u201c$\u201d al final. Probablemente las cuentas de usuario m\u00e1s importantes son Administrator y krbtgt. La primera tiene privilegios altos en el sistema y la segunda permite el cifrado de los tickets TGT, lo que significa que si un atacante compromete dicha cuenta podr\u00e1 crear este tipo de tickets sin problema. A esta t\u00e9cnica se le conoce como Golden Ticket. Base de datos NTDS La base de datos de un AD contiene todos los objetos que se encuentran disponibles en el entorno y se comparte/sincroniza con todos los DC. Por defecto, se encuentra ubicada en el fichero C:\\Windows\\NTDS\\ntds.dit de cada DC. Por otro lado, la NTDS se caracteriza por dos cosas: Es una base de datos distribuida. Cuenta con una estructura basada en objetos y jerarqu\u00edas de clases. El archivo NTDS.dit es una base de datos que almacena datos de Active Directory, incluida informaci\u00f3n sobre objetos de usuario, grupos y pertenencia a grupos. Incluye los hashes NTLM de las contrase\u00f1as para todos los usuarios y computadores. Al extraer estos hashes, es posible utilizar herramientas como Mimikatz para realizar ataques de pass-the-hash o herramientas como Hashcat para descifrar estas contrase\u00f1as. La extracci\u00f3n y el descifrado de estas contrase\u00f1as se pueden realizar sin conexi\u00f3n, por lo que ser\u00e1n indetectables. Una vez que un atacante ha extra\u00eddo estos hashes, puede actuar como cualquier usuario, incluidos los administradores de dominio. GPOs \u00bfQu\u00e9 es una directiva de grupo? Lo primero es lo primero, \u00bfqu\u00e9 es una directiva de grupo? La directiva de grupo es una caracter\u00edstica de Windows que facilita una amplia variedad de configuraciones avanzadas que los administradores de sistemas pueden usar para controlar el entorno de trabajo de los usuarios y las cuentas de usuario en Active Directory. B\u00e1sicamente, proporciona un lugar centralizado para que los administradores administren y configuren los sistemas operativos, las aplicaciones y los ajustes de los usuarios. Las pol\u00edticas de grupo, cuando se usan correctamente, permiten aumentar la seguridad de las computadoras de los usuarios y ayudarlo a defenderse tanto de las amenazas internas como de los ataques externos. \u00bfQu\u00e9 es un objeto de directiva de grupo o Group Policy Object (GPO)? Un objeto de directiva de grupo (GPO) es un grupo de configuraciones que se crean mediante el Editor de directivas de grupo de Microsoft Management Console (MMC). Los GPO se pueden asociar con uno o varios contenedores de Active Directory, incluidos sitios, dominios o unidades organizativas (OU). MMC permite a los usuarios crear GPO que definen pol\u00edticas basadas en el registro, opciones de seguridad, instalaci\u00f3n de software y mucho m\u00e1s. Active Directory aplica los GPO en el mismo orden l\u00f3gico; pol\u00edticas locales, pol\u00edticas de sitio, pol\u00edticas de dominio y pol\u00edticas de OU. Nota Nota: Los GPO que est\u00e1n en unidades organizativas anidadas funcionan primero desde la unidad organizativa m\u00e1s cercana a la ra\u00edz y desde all\u00ed hacia afuera. Ejemplos de GPO Los Objetos de directiva de grupo o GPO se pueden usar de varias formas para que beneficien a la seguridad. A continuaci\u00f3n se muestran algunos ejemplos concretos: Una GPO podr\u00eda usarse para determinar la p\u00e1gina de inicio que un usuario ve cuando inicia su navegador de Internet despu\u00e9s de iniciar sesi\u00f3n en el dominio. Los administradores pueden usar GPO para definir qu\u00e9 impresoras conectadas a la red aparecen en la lista de impresoras disponibles despu\u00e9s de que un usuario en una OU de Active Directory espec\u00edfica inicia sesi\u00f3n en el dominio. Los administradores tambi\u00e9n pueden usar GPO para modificar una serie de protocolos y pr\u00e1cticas de seguridad, como restringir las opciones de conexi\u00f3n a Internet, los programas e incluso el tiempo de pantalla inactiva. Restringir el acceso al panel de control y Configuraci\u00f3n Bloquear acceso al s\u00edmbolo del sistema Impedir la instalaci\u00f3n de software Desactivar las actualizaciones autom\u00e1ticas de controladores. \u00bfC\u00f3mo se procesan los objetos de directiva de grupo? El orden en el que se procesan los GPO afecta la configuraci\u00f3n que se aplica al equipo y al usuario. El orden en que se procesan los GPO se conoce como LSDOU, que significa local, sitio(una especie de subred en nuestro dominio), dominio, unidad organizativa. La pol\u00edtica de la computadora local es la primera en ser procesada, seguida del nivel del sitio a las pol\u00edticas de AD de dominio, y finalmente en las unidades de la organizaci\u00f3n. Si hay pol\u00edticas en conflicto en LSDOU, las \u00faltimas pol\u00edticas aplicadas ganan. Beneficios de las GPOs Los beneficios de la pol\u00edtica de grupo no se limitan \u00fanicamente a la seguridad, hay una serie de otras ventajas que vale la pena mencionar. Pol\u00edtica de contrase\u00f1as: muchas empresas tienen pol\u00edticas de contrase\u00f1as demasiado laxas, y muchos usuarios a menudo tienen contrase\u00f1as configuradas para que nunca caduquen. Las contrase\u00f1as que no se rotan regularmente, son demasiado simples o usan palabras comunes corren el riesgo de ser vulneradas por fuerza bruta. Los GPO se pueden utilizar para establecer la longitud, la complejidad y otros requisitos de la contrase\u00f1a. Gesti\u00f3n de sistemas: los GPO se pueden utilizar para simplificar tareas sencillas y repetitivas, ahorrando as\u00ed mucho tiempo. Pueden ahorrar horas y horas de configuraci\u00f3n del entorno de nuevos usuarios y equipos que se unen al dominio mediante el uso de GPOs para aplicar una configuraci\u00f3n universal y est\u00e1ndar. Verificaci\u00f3n de estado: los GPO se pueden usar para implementar actualizaciones de software y parches del sistema para garantizar que su entorno est\u00e9 en buen estado y actualizado contra las \u00faltimas amenazas de seguridad. Limitaciones de las GPOs Estar\u00edamos faltando a la verdad si dijeramos que los GPO son la f\u00f3rmula m\u00e1gica para mantener los datos seguros. Hay una serie de limitaciones que se deben conocer. En primer lugar, el editor de GPO no es la consola m\u00e1s f\u00e1cil de usar, m\u00e1s bien es un tanto adusto. Un conocimiento profundo de PowerShell ayudar\u00e1 a que sea m\u00e1s f\u00e1cil realizar todas las actualizaciones de GPO, lo cual complica m\u00e1s la cosa si cabe. Las actualizaciones de GPO, se realizan aleatoriamente cada 90 a 120 minutos cada vez que se reinicia la computadora.Puede espec\u00edficarse una tasa de actualizaci\u00f3n desde 0 minutos hasta 45 d\u00edas. Sin embargo, si se especifican 0 minutos, entonces, de forma predeterminada, las GPO intentar\u00e1n actualizarse cada 7 segundos, lo que probablemente inunde la red de tr\u00e1fico. Los GPO tampoco son inmunes a los ciberataques. Si un atacante quisiera cambiar las GPO locales en una computadora para moverse lateralmente a trav\u00e9s de la red, ser\u00eda muy dif\u00edcil detectarlo sin una soluci\u00f3n de auditor\u00eda y monitoreo de pol\u00edticas de grupo implementada.","title":"Entornos Windows"},{"location":"section/EntWin/#entornos-windows","text":"","title":"Entornos Windows"},{"location":"section/EntWin/#active-directory","text":"Empresas de todos los tama\u00f1os en todo el mundo utilizan Active Directory para administrar los permisos y controlar el acceso a los recursos cr\u00edticos de la red empresarial. Pero, \u00bfqu\u00e9 es exactamente y c\u00f3mo afecta al negocio?","title":"Active Directory"},{"location":"section/EntWin/#que-es-active-directory","text":"Active Directory (AD) es un servicio de directorio que se ejecuta en Microsoft Windows Server. Un directorio es una estructura jer\u00e1rquica que almacena informaci\u00f3n sobre los objetos en la red. La funci\u00f3n principal de Active Directory es permitir que los administradores del sistema manejen permisos y controlen el acceso a los recursos de la red. En Active Directory, los datos se almacenan como objetos, que incluyen usuarios, grupos, aplicaciones, servicios o dispositivos, y estos objetos se clasifican seg\u00fan su nombre y atributos. Active Directory usa un almac\u00e9n de datos estructurado como base para una organizaci\u00f3n jer\u00e1rquica l\u00f3gica de la informaci\u00f3n del directorio. Definici\u00f3n El directorio activo o Active Directory (AD) es una manera de organizar y gestionar todos los elementos de una red inform\u00e1tica: ordenadores, grupos, usuarios, dominios, pol\u00edticas de seguridad, y cualquier tipo de objetos definidos para el usuario. AD simplifica la vida de los administradores y usuarios finales al tiempo que mejora la seguridad de las organizaciones a trav\u00e9s de la funci\u00f3n pol\u00edticas de grupo de AD. Los usuarios pueden autenticarse una vez y luego acceder sin problemas a cualquier recurso en el dominio para el que est\u00e1n autorizados (inicio de sesi\u00f3n \u00fanico). Adem\u00e1s, los archivos se almacenan en un repositorio central donde se pueden compartir con otros usuarios para facilitar la colaboraci\u00f3n y los equipos de TI pueden respaldarlos adecuadamente para garantizar la continuidad del negocio.","title":"\u00bfQu\u00e9 es Active Directory?"},{"location":"section/EntWin/#antes-de-nada-que-es-un-dominio","text":"Un dominio representa una agrupaci\u00f3n l\u00f3gica de un conjunto ordenadores conectados en una red los cuales comparten una base de datos de Active Directory. La base de base de datos es probablemente el elemento m\u00e1s importante en un AD (Active Directory) y es gestionada por los servidores centrales del dominio, tambi\u00e9n conocidos como Domain Controllers. Un dominio b\u00e1sicamente es una etiqueta que t\u00edpicamente representa un nombre DNS, el cual en algunas organizaciones es el mismo que su sitio web, pero no tiene porque ser as\u00ed en todos los casos y es posible que la organizaci\u00f3n prefiera utilizar otro nombre de dominio que ser\u00e1 al que se unir\u00e1n las estaciones de trabajo.","title":"Antes de nada, \u00bfqu\u00e9 es un dominio?"},{"location":"section/EntWin/#que-son-los-domain-services-sevicios-de-dominio-de-active-directory","text":"Los servicios de dominio de Active Directory (AD DS) son un componente central de Active Directory y proporcionan el mecanismo principal para autenticar a los usuarios y determinar a qu\u00e9 recursos de red pueden acceder. Los servidores que ejecutan AD DS se denominan controladores de dominio (DC). \u00c9stos son sistemas basados en Windows Server que pueden acceder y manipular la base de datos del AD. Cada dominio tiene como m\u00ednimo un controlador, por lo que si por ejemplo, un departamento o unidad de negocio crece m\u00e1s de lo esperado, es posible instalar m\u00e1s controladores de dominio dedicados a procesar las solicitudes de las estaciones de trabajo en ese departamento. Tambi\u00e9n es posible crear subdominios para que los usuarios puedan acceder a los recursos en otros subdominios que hagan parte del mismo Forest. Las organizaciones normalmente tienen varios DC y cada uno tiene una copia del directorio para todo el dominio. Los cambios realizados en el directorio en un controlador de dominio, como la actualizaci\u00f3n de la contrase\u00f1a o la eliminaci\u00f3n de una cuenta de usuario, se replican en los otros controladores de dominio para que todos est\u00e9n actualizados. AD DS tambi\u00e9n proporciona caracter\u00edsticas adicionales como inicio de sesi\u00f3n \u00fanico (SSO) mediante Kerberos, certificados de seguridad, LDAP (protocolo ligero de acceso a directorios) y administraci\u00f3n de derechos de acceso.","title":"\u00bfQu\u00e9 son los Domain Services (sevicios de dominio) de Active Directory?"},{"location":"section/EntWin/#la-estructura-jerarquica-de-los-servicios-de-dominio-de-active-directory","text":"Los dominios en AD son muy flexibles y permiten crear una infraestructura completa y bien organizada. Partiendo de un dominio ra\u00edz, es posible crear subdominios que representen la disposici\u00f3n f\u00edsica y/o l\u00f3gica de las estaciones de trabajo. Esto significa que se puede crear un subdominio para el departamento de ventas, IT, marketing, etc. Tambi\u00e9n se podr\u00eda crear subdominios para las oficinas que se encuentran distribuidas en diferentes ubicaciones geogr\u00e1ficas. Evidentemente, se trata de decisiones de dise\u00f1o a la hora de configurar la red. AD DS organiza los datos en una estructura jer\u00e1rquica que consta de dominios, \u00e1rboles y bosques, como se detalla a continuaci\u00f3n. Dominios: un dominio representa un grupo de objetos, como usuarios, grupos y dispositivos, que comparten la misma base de datos de AD. Puedes pensar en un dominio como una rama en un \u00e1rbol. Un dominio tiene la misma estructura que los dominios y subdominios est\u00e1ndar, por ejemplo, tudominio.com y ventas.tudominio.com. Un dominio representa un l\u00edmite de administraci\u00f3n. Los objetos de un dominio determinado se almacenan en una \u00fanica base de datos y se pueden administrar juntos. \u00c1rboles: un \u00e1rbol es uno o m\u00e1s dominios agrupados en una jerarqu\u00eda l\u00f3gica. Dado que los dominios de un \u00e1rbol est\u00e1n relacionados, se dice que \"conf\u00edan\" entre s\u00ed. Bosque: un bosque es el nivel m\u00e1s alto de organizaci\u00f3n dentro de AD y contiene un grupo de \u00e1rboles. Los \u00e1rboles de un bosque tambi\u00e9n pueden confiar entre s\u00ed y tambi\u00e9n compartir\u00e1n esquemas de directorio, cat\u00e1logos, informaci\u00f3n de aplicaciones y configuraciones de dominio. Un bosque representa un l\u00edmite de seguridad. Los objetos de diferentes bosques no pueden interactuar entre s\u00ed a menos que los administradores de cada bosque creen una relaci\u00f3n de confianza entre ellos Unidades organizativas: una unidad organizativa permite, como su propio nombre indica, organizar y agrupar usuarios, grupos, equipos y otras unidades organizativas. Las unidades organizativas (OU) de un dominio administrado de Active Directory Domain Services (AD DS) permiten agrupar l\u00f3gicamente objetos como cuentas de usuario, cuentas de servicio o cuentas de equipo. Despu\u00e9s, se puede asignar administradores a unidades organizativas espec\u00edficas y aplicar la directiva de grupo para aplicar los valores de configuraci\u00f3n de destino. Contenedores: un contenedor es similar a una unidad organizativa; sin embargo, a diferencia de una unidad organizativa, no es posible vincular un objeto de directiva de grupo (GPO) a un contenedor gen\u00e9rico de Active Directory.","title":"La estructura jer\u00e1rquica de los servicios de dominio de Active Directory"},{"location":"section/EntWin/#otros-servicios-de-active-directory","text":"Adem\u00e1s de los servicios de dominio de Active Directory, hay varios otros servicios cr\u00edticos que proporciona AD. Algunos de esos servicios se enumeran a continuaci\u00f3n: Servicios de directorio ligeros: AD LDS es un servicio de directorio del Protocolo ligero de acceso a directorios (LDAP). Proporciona solo un subconjunto de las funciones de AD DS, lo que lo hace m\u00e1s vers\u00e1til en t\u00e9rminos de d\u00f3nde se puede ejecutar. Por ejemplo, se puede ejecutar como un servicio de directorio independiente sin necesidad de integrarse con una implementaci\u00f3n completa de Active Directory. Servicios de certificados: puede crear, administrar y compartir certificados de cifrado, que permiten a los usuarios intercambiar informaci\u00f3n de forma segura a trav\u00e9s de Internet. Servicios de federaci\u00f3n de Active Directory: ADFS es una soluci\u00f3n de inicio de sesi\u00f3n \u00fanico (SSO) para AD que permite a los empleados acceder a m\u00faltiples aplicaciones con un \u00fanico conjunto de credenciales, lo que simplifica la experiencia del usuario. Servicios de administraci\u00f3n de derechos: AD RMS es un conjunto de herramientas que ayuda con la administraci\u00f3n de tecnolog\u00edas de seguridad que ayudar\u00e1n a las organizaciones a mantener sus datos seguros. Dichas tecnolog\u00edas incluyen cifrado, certificados y autenticaci\u00f3n, y cubren una variedad de aplicaciones y tipos de contenido, como correos electr\u00f3nicos y documentos de Word. El servidor que aloja AD DS se denomina controlador de dominio (DC) . Tambi\u00e9n se puede usar un controlador de dominio para autenticarse con otros productos de MS, como Exchange Server, SharePoint Server, SQL Server, File Server u otros. Atenci\u00f3n El controlador de dominio, hablando de ciberseguridad en entornos Windows, es la joya de la corona . Bien sea realizando un pentest legal, bien sea un ataque malintencionado por parte de ciberdelincuentes, el fin \u00faltimo siempre ser\u00e1 llegar a ser administrador del Controlador de Dominio (DC). Por ello es tremendamente importante conocer su complejo funcionamiento y saber fortificarlo en la medida de lo posible para protegernos frente a los ataques m\u00e1s comunes.","title":"Otros servicios de Active Directory"},{"location":"section/EntWin/#usuarios-de-ad","text":"Entre otras cosas, Active Directory gestiona los usuarios del entorno trat\u00e1ndolos como un tipo de objeto especial que se almacena en la base de datos central. A continuaci\u00f3n se listan algunas cuestiones importantes a tener en cuenta sobre los usuarios de un dominio. Aunque el nombre de usuario sirve para identificarle, el SID (Security Identifier) tambi\u00e9n puede ser utilizado para dicho fin. El SID es la combinaci\u00f3n del Domain SID y el RID (Relative Identifier). Algunas herramientas ense\u00f1an el SID en lugar del nombre de usuario, por ese motivo es importante saber esto. Los user secrets son elementos utilizados por el Domain Controller para realizar el proceso de autenticaci\u00f3n. Las contrase\u00f1as no se guardan en texto plano, pero los user secrets derivados de ellas s\u00ed, los cuales son Hashes NT y claves Kerberos. Los hashes LM y NT son almacenados en dos sitios: La SAM (Security Account Manager) de Windows y la base de datos del AD, la cual por defecto se encuentra disponible en los DC en la ruta C:\\Windows\\NTDS\\ntds.dit. Aunque los hashes NT no son contrase\u00f1as, se pueden utilizar en algunos casos para ataques del tipo Pass-The-Hash/Overpass-The-Hash Los ordenadores registrados en un AD tambi\u00e9n est\u00e1n representados por una cuenta de usuario, la cual es el nombre de la estaci\u00f3n de trabajo con un \u201c$\u201d al final. Probablemente las cuentas de usuario m\u00e1s importantes son Administrator y krbtgt. La primera tiene privilegios altos en el sistema y la segunda permite el cifrado de los tickets TGT, lo que significa que si un atacante compromete dicha cuenta podr\u00e1 crear este tipo de tickets sin problema. A esta t\u00e9cnica se le conoce como Golden Ticket.","title":"Usuarios de AD"},{"location":"section/EntWin/#base-de-datos-ntds","text":"La base de datos de un AD contiene todos los objetos que se encuentran disponibles en el entorno y se comparte/sincroniza con todos los DC. Por defecto, se encuentra ubicada en el fichero C:\\Windows\\NTDS\\ntds.dit de cada DC. Por otro lado, la NTDS se caracteriza por dos cosas: Es una base de datos distribuida. Cuenta con una estructura basada en objetos y jerarqu\u00edas de clases. El archivo NTDS.dit es una base de datos que almacena datos de Active Directory, incluida informaci\u00f3n sobre objetos de usuario, grupos y pertenencia a grupos. Incluye los hashes NTLM de las contrase\u00f1as para todos los usuarios y computadores. Al extraer estos hashes, es posible utilizar herramientas como Mimikatz para realizar ataques de pass-the-hash o herramientas como Hashcat para descifrar estas contrase\u00f1as. La extracci\u00f3n y el descifrado de estas contrase\u00f1as se pueden realizar sin conexi\u00f3n, por lo que ser\u00e1n indetectables. Una vez que un atacante ha extra\u00eddo estos hashes, puede actuar como cualquier usuario, incluidos los administradores de dominio.","title":"Base de datos NTDS"},{"location":"section/EntWin/#gpos","text":"","title":"GPOs"},{"location":"section/EntWin/#que-es-una-directiva-de-grupo","text":"Lo primero es lo primero, \u00bfqu\u00e9 es una directiva de grupo? La directiva de grupo es una caracter\u00edstica de Windows que facilita una amplia variedad de configuraciones avanzadas que los administradores de sistemas pueden usar para controlar el entorno de trabajo de los usuarios y las cuentas de usuario en Active Directory. B\u00e1sicamente, proporciona un lugar centralizado para que los administradores administren y configuren los sistemas operativos, las aplicaciones y los ajustes de los usuarios. Las pol\u00edticas de grupo, cuando se usan correctamente, permiten aumentar la seguridad de las computadoras de los usuarios y ayudarlo a defenderse tanto de las amenazas internas como de los ataques externos.","title":"\u00bfQu\u00e9 es una directiva de grupo?"},{"location":"section/EntWin/#que-es-un-objeto-de-directiva-de-grupo-o-group-policy-object-gpo","text":"Un objeto de directiva de grupo (GPO) es un grupo de configuraciones que se crean mediante el Editor de directivas de grupo de Microsoft Management Console (MMC). Los GPO se pueden asociar con uno o varios contenedores de Active Directory, incluidos sitios, dominios o unidades organizativas (OU). MMC permite a los usuarios crear GPO que definen pol\u00edticas basadas en el registro, opciones de seguridad, instalaci\u00f3n de software y mucho m\u00e1s. Active Directory aplica los GPO en el mismo orden l\u00f3gico; pol\u00edticas locales, pol\u00edticas de sitio, pol\u00edticas de dominio y pol\u00edticas de OU. Nota Nota: Los GPO que est\u00e1n en unidades organizativas anidadas funcionan primero desde la unidad organizativa m\u00e1s cercana a la ra\u00edz y desde all\u00ed hacia afuera.","title":"\u00bfQu\u00e9 es un objeto de directiva de grupo o Group Policy Object (GPO)?"},{"location":"section/EntWin/#ejemplos-de-gpo","text":"Los Objetos de directiva de grupo o GPO se pueden usar de varias formas para que beneficien a la seguridad. A continuaci\u00f3n se muestran algunos ejemplos concretos: Una GPO podr\u00eda usarse para determinar la p\u00e1gina de inicio que un usuario ve cuando inicia su navegador de Internet despu\u00e9s de iniciar sesi\u00f3n en el dominio. Los administradores pueden usar GPO para definir qu\u00e9 impresoras conectadas a la red aparecen en la lista de impresoras disponibles despu\u00e9s de que un usuario en una OU de Active Directory espec\u00edfica inicia sesi\u00f3n en el dominio. Los administradores tambi\u00e9n pueden usar GPO para modificar una serie de protocolos y pr\u00e1cticas de seguridad, como restringir las opciones de conexi\u00f3n a Internet, los programas e incluso el tiempo de pantalla inactiva. Restringir el acceso al panel de control y Configuraci\u00f3n Bloquear acceso al s\u00edmbolo del sistema Impedir la instalaci\u00f3n de software Desactivar las actualizaciones autom\u00e1ticas de controladores.","title":"Ejemplos de GPO"},{"location":"section/EntWin/#como-se-procesan-los-objetos-de-directiva-de-grupo","text":"El orden en el que se procesan los GPO afecta la configuraci\u00f3n que se aplica al equipo y al usuario. El orden en que se procesan los GPO se conoce como LSDOU, que significa local, sitio(una especie de subred en nuestro dominio), dominio, unidad organizativa. La pol\u00edtica de la computadora local es la primera en ser procesada, seguida del nivel del sitio a las pol\u00edticas de AD de dominio, y finalmente en las unidades de la organizaci\u00f3n. Si hay pol\u00edticas en conflicto en LSDOU, las \u00faltimas pol\u00edticas aplicadas ganan.","title":"\u00bfC\u00f3mo se procesan los objetos de directiva de grupo?"},{"location":"section/EntWin/#beneficios-de-las-gpos","text":"Los beneficios de la pol\u00edtica de grupo no se limitan \u00fanicamente a la seguridad, hay una serie de otras ventajas que vale la pena mencionar. Pol\u00edtica de contrase\u00f1as: muchas empresas tienen pol\u00edticas de contrase\u00f1as demasiado laxas, y muchos usuarios a menudo tienen contrase\u00f1as configuradas para que nunca caduquen. Las contrase\u00f1as que no se rotan regularmente, son demasiado simples o usan palabras comunes corren el riesgo de ser vulneradas por fuerza bruta. Los GPO se pueden utilizar para establecer la longitud, la complejidad y otros requisitos de la contrase\u00f1a. Gesti\u00f3n de sistemas: los GPO se pueden utilizar para simplificar tareas sencillas y repetitivas, ahorrando as\u00ed mucho tiempo. Pueden ahorrar horas y horas de configuraci\u00f3n del entorno de nuevos usuarios y equipos que se unen al dominio mediante el uso de GPOs para aplicar una configuraci\u00f3n universal y est\u00e1ndar. Verificaci\u00f3n de estado: los GPO se pueden usar para implementar actualizaciones de software y parches del sistema para garantizar que su entorno est\u00e9 en buen estado y actualizado contra las \u00faltimas amenazas de seguridad.","title":"Beneficios de las GPOs"},{"location":"section/EntWin/#limitaciones-de-las-gpos","text":"Estar\u00edamos faltando a la verdad si dijeramos que los GPO son la f\u00f3rmula m\u00e1gica para mantener los datos seguros. Hay una serie de limitaciones que se deben conocer. En primer lugar, el editor de GPO no es la consola m\u00e1s f\u00e1cil de usar, m\u00e1s bien es un tanto adusto. Un conocimiento profundo de PowerShell ayudar\u00e1 a que sea m\u00e1s f\u00e1cil realizar todas las actualizaciones de GPO, lo cual complica m\u00e1s la cosa si cabe. Las actualizaciones de GPO, se realizan aleatoriamente cada 90 a 120 minutos cada vez que se reinicia la computadora.Puede espec\u00edficarse una tasa de actualizaci\u00f3n desde 0 minutos hasta 45 d\u00edas. Sin embargo, si se especifican 0 minutos, entonces, de forma predeterminada, las GPO intentar\u00e1n actualizarse cada 7 segundos, lo que probablemente inunde la red de tr\u00e1fico. Los GPO tampoco son inmunes a los ciberataques. Si un atacante quisiera cambiar las GPO locales en una computadora para moverse lateralmente a trav\u00e9s de la red, ser\u00eda muy dif\u00edcil detectarlo sin una soluci\u00f3n de auditor\u00eda y monitoreo de pol\u00edticas de grupo implementada.","title":"Limitaciones de las GPOs"},{"location":"section/privesc/","text":"Qu\u00e9 es una escalada de privilegios? La escalada de privilegios ocurre cuando un usuario malicioso o malintencionado aprovecha una vulnerabilidad, un defecto de dise\u00f1o o un error de configuraci\u00f3n en una aplicaci\u00f3n o sistema operativo para obtener un acceso elevado a los recursos que normalmente no deber\u00edan estar disponibles para ellos. El atacante puede usar los privilegios reci\u00e9n obtenidos para robar datos confidenciales, ejecutar comandos administrativos o implementar malware, y potencialmente causar da\u00f1os graves a su sistema operativo, aplicaciones de servidor, organizaci\u00f3n y reputaci\u00f3n Un escenario t\u00edpico donde se produce una escalada de privilegios es cuando un atacante ya ha conseguido comprometer un sistema y ha obtenido un acceso mediante una cuenta con bajos privilegios. Tras este paso inicial el atacante se encuentra con una situaci\u00f3n donde debe obtener mayores privilegios si quiere realmente comprometer todo el sistema u otras partes de la red. As\u00ed pues, digamos que la escalada de privilegios es el paso siguiente tras obtener un punto de entrada inicial al sistema por parte de un atacante. Tipos de escaladas de privilegios Como ya hemos dicho, en general, los atacantes aprovechan las vulnerabilidades de escalamiento de privilegios en la fase de ataque inicial para anular las limitaciones de su cuenta de usuario inicial en un sistema o aplicaci\u00f3n. Hay dos tipos principales de escalada de privilegios: escalada de privilegios horizontal para acceder a la funcionalidad y los datos de un usuario diferente y escalada de privilegios vertical para obtener privilegios elevados, generalmente de un administrador del sistema u otro usuario avanzado. Con la escalada horizontal de privilegios , los actores malintencionados permanecen en el mismo nivel general de privilegios, pero pueden acceder a los datos o la funcionalidad de otras cuentas o procesos que no deber\u00edan estar disponibles para ellos. Por ejemplo, esto puede significar usar un equipo comprometido para obtener acceso a los datos de otros usuarios de la oficina. Para las aplicaciones web, un ejemplo de escalamiento horizontal podr\u00eda ser el uso de secuestro de sesi\u00f3n para evitar la autenticaci\u00f3n y obtener acceso a la cuenta de otro usuario en una red social, una plataforma de comercio electr\u00f3nico o un sitio de banca electr\u00f3nica. M\u00e1s peligrosa es la escalada vertical de privilegios (tambi\u00e9n llamada elevaci\u00f3n de privilegios ), donde el atacante obtiene los derechos de una cuenta con m\u00e1s privilegios, generalmente el administrador o usuario del sistema en Microsoft Windows o root en sistemas Unix y Linux. Con este elevado nivel de acceso, el atacante puede causar todo tipo de estragos en sus sistemas inform\u00e1ticos y aplicaciones: robar credenciales de acceso y datos confidenciales, descargar y ejecutar ransomware, borrar datos o ejecutar c\u00f3digo arbitrario. Los atacantes avanzados utilizar\u00e1n privilegios elevados para cubrir sus pistas eliminando los registros de acceso y otras pruebas de su actividad, sin que la v\u00edctima se d\u00e9 cuenta de que se ha producido un ataque. De esa forma, los ciberdelincuentes pueden robar informaci\u00f3n de forma encubierta y colocar puertas traseras u otro malware en los sistemas de la empresa. Se suelen utilizar 5 m\u00e9todos principalmente para llevar a cabo la escalada de privilegios: Explotaci\u00f3n de credenciales Vulnerabilidades y exploits Configuraciones incorrectas Software malicioso Ingenier\u00eda social \u00bfC\u00f3mo prevenir y mitigar los ataques de escalada de privilegios? Debido a que los ataques de escalada de privilegios pueden iniciarese y avanzar de muchas formas diferentes, se requieren m\u00faltiples estrategias y t\u00e1cticas de defensa para protegernos. Sin embargo, la implementaci\u00f3n de un enfoque centrado en la identidad y en controles de administraci\u00f3n de acceso privilegiado permiten protegerse contra la gama m\u00e1s amplia de ataques, as\u00ed como reducir la superficie de ataque. Estas son algunas de las mejores pr\u00e1cticas: Administrar completamente el ciclo de vida de la autenticaci\u00f3n , incluido el aprovisionamiento y desaprovisionamiento de identidades y cuentas para garantizar que no haya cuentas hu\u00e9rfanas que puedan ser secuestradas. Utilizar un mecanismo de administraci\u00f3n de contrase\u00f1as para aplicar pol\u00edticas s\u00f3lidas de administraci\u00f3n de credenciales tanto para humanos como para m\u00e1quinas. Esto tambi\u00e9n implica eliminar la credencial predeterminada y \"hardcodeada\". Aplicar el privilegio m\u00ednimo: eliminar los derechos de administrador de los usuarios y reducir los privilegios de la aplicaci\u00f3n y la m\u00e1quina al m\u00ednimo requerido. Tambi\u00e9n se debe implementar el acceso \"just-in-time\" para reducir los privilegios permanentes o permanentes. Supervisar y administrar todas las sesiones privilegiadas para detectar y abordar r\u00e1pidamente cualquier actividad sospechosa que pueda indicar una cuenta secuestrada o un intento il\u00edcito de escalada de privilegios o movimiento lateral. Fortalecer los sistemas y las aplicaciones: esto complementa el principio de privilegios m\u00ednimos y puede implicar cambios de configuraci\u00f3n, eliminaci\u00f3n de derechos y accesos innecesarios, cierre de puertos y m\u00e1s. Esto mejora la seguridad del sistema y las aplicaciones y ayuda a prevenir y mitigar los errores potenciales que puedan llevar a una vulnerabilidad de inyecci\u00f3n de c\u00f3digo malicioso, desbordamientos de b\u00fafer u otras puertas traseras que podr\u00edan permitir la escalada de privilegios. Gesti\u00f3n de vulnerabilidades: identifique y aborde de forma continua las vulnerabilidades, mediante parches, correcci\u00f3n de configuraciones incorrectas, eliminaci\u00f3n de credenciales predeterminadas y/o integradas, entre otras. El acceso remoto seguro siempre debe monitorearse y administrarse para cualquier forma de acceso privilegiado, ya que los ataques pueden ocurrir horizontal y verticalmente para explotar los privilegios. Escalada de privilegios en Linux En Linux nuestro objetivo con la escalada de privilegios va a ser siempre obetner una shell corriendo con privilegios del usuario root . En muchos casos la escalada de privilegios no recaer\u00e1 simplemente en una simple mala configuraci\u00f3n, sino que requererir\u00e1 combinar varios m\u00e9todos, debilidades y malas configuraciones para conseguirla. Todas las escaladas de privilegios son ejemplos fehacientes de una violaci\u00f3n de los controles de acceso. Puesto ques los controles de acceso y los permisos de usuario est\u00e1n estrechamente ligados, es crucial entender como funcionan los permisos en Linux, tal y como ya hemos visto con anterioridad. Pasemos ahora a ver algunas de las t\u00e9cnicas que permiten la escalada de privilegios en sistemas Linux.. Ejercicios Cada una de las siguientes escaladas de privilegios la vamos a probar en la sala Linux PrivEsc de Tryhackme a la que deb\u00e9is uniros. Permisos \"d\u00e9biles\" o incorrectos en archivos Es posible aprovecharse de algunos archivos de sistema para la escalada de privilegios si los permisos de estos archivos son incorrectos. Si un archivo tiene informaci\u00f3n confidencial que podamos leer, podremos usarlo para conseguir el acceso a la cuenta de root. Por otra parte, si nos topamos con un archivo de sistema sobre el que tenemos permisos de escritura, podremos modificar el comportamiento del sistema operativo y obtener acceso root de este modo. Algunos comandos \u00fatiles: Encontrar todos los archivos sobre los que tenemos permiso de escritura en /etc : $ find /etc -maxdepth 1 -writable -type f Encontrar todos los archivos sobre los que tenemos permiso de lectura en /etc : $ find /etc -maxdepth 1 -readable -type f Encontrar todos los directorios sobre los que tenemos permiso de escritura: $ find / -executable -writable -type d 2 > /dev/null Task 3, 4 y 5 de THM El archivo /etc/shadow contiene los hashes de las contrase\u00f1as de usuario, y por de forma predeterminada no es legible por ning\u00fan usuario excepto root. Si podemos leer el contenido del archivo /etc/shadow, podr\u00edamos descifrar el hash de la contrase\u00f1a del usuario root. Si pudi\u00e9ramos modificar el archivo /etc/shadow, podemos reemplazar el hash de la contrase\u00f1a del usuario ra\u00edz con uno que conocemos. Secuencias de escape En la mayor\u00eda de ocasiones tenemos restricciones para ejecutar \u00fanicamente ciertos programas a trav\u00e9s de sudo. No obstante, puede darse el caso de que pueda \"escapar\" del programa y generar una shell. Cuando un programa se ejecuta con privilegios de root, tambi\u00e9n lo hace la shell que genera, por lo que puedo intentar conseguir una shell a trav\u00e9s de la ejecuci\u00f3n de ese programa. Se puede consultar una lista de programas con sus secuencias de escape correspondientes en GTFObins Procedimiento: Listar los programas que un usuario tiene permitido ejecutar como sudo : $ sudo -l ... ( root ) NOPASSWD: /usr/sbin/iftop ( root ) NOPASSWD: /usr/bin/find ( root ) NOPASSWD: /usr/bin/nano ( root ) NOPASSWD: /usr/bin/vim ( root ) NOPASSWD: /usr/bin/man ( root ) NOPASSWD: /usr/bin/awk ... Para cada programa de la lista, comprobar si existe una secuencia de escape en GTFObins Si existe una secuencia de escapa, ejecutar el programa con sudo e intentar utilizar dcha secuencia para desplegar una shell de root. Task 6 de THM Obt\u00e9n un terminal de root haciendo uso al menos de 3 secuencias de escape diferentes Tareas del cron y permisos de archivos Las tareas programadas en el cron son programas o scripts cuyos usuarios pueden programar para que se ejecuten en momentos concretos o a intervalos. Las tareas del cron se ejecutan con el nivel de seguridad del usuario propietario de las mismas. Por defecto, las tareas del cron usan el terminal /bin/bash con determinadas limitaciones. La configuraci\u00f3n de estas tareas se realiza en crontab . Los crontab de los usuarios suelen esar localizados en /var/spool/cron/ o /var/spool/cron/crontabs El crontab del sistema est\u00e1 ubicado en /etc/crontab . Task 8 de THM Consigue una shell de root aprovech\u00e1ndote de la mala configuraci\u00f3n del crontab. Shell inversa Ayuda para entender los conceptos shell directa y shell inversa Archivos de historial Los archivos de historial registran los comandos utilizados por los usuarios mientras est\u00e1n usando ciertos programas. Si un usuario escribe una contrase\u00f1a como parte de un comando, esta contrase\u00f1a puede almacenarse en un archivo de historial. Como atacante, siempre es una buena idea intentar cambiar al usuario root con un contrase\u00f1a que ha sido revelada mediante este m\u00e9todo.. Task 16 de THM Consigue una shell de root aprovech\u00e1ndote del historial de comandos. Archivos de configuraci\u00f3n Muchos servicios y programas utilizan archivos de texto (config) para almacenar la configuraci\u00f3n. Si un servicio necesita autenticarse en algo, puede almacenar las credenciales en un archivo de configuraci\u00f3n a pesar de ser una muy mala pr\u00e1ctica. Si se puede acceder a estos archivos de configuraci\u00f3n y los usuarios privilegiados reutilizan las contrase\u00f1as que almacenan, es posible que podamos usarlos para iniciar sesi\u00f3n como ese usuario en otros servicios o sistemas. Task 17 de THM Consigue una shell de root aprovech\u00e1ndote de la informaci\u00f3n encontrada en alg\u00fan archivo de configuraci\u00f3n. Claves SSH Se pueden utilizar claves SSH en lugar de contrase\u00f1as para autenticar a los usuarios mediante SSH. Las claves SSH vienen en pares: una clave privada y una clave p\u00fablica. La clave privada siempre debe mantenerse en secreto. Si un usuario ha almacenado su clave privada de forma insegura, cualquiera que pueda leer la clave puede iniciar sesi\u00f3n en su cuenta us\u00e1ndola. Task 18 de THM Consigue una shell de root aprovech\u00e1ndote de las claves SSH del sistema. Escalada de privilegios en Windows En una escalada de privilegios en Windows nuestro objetivo ser\u00e1 obtener una shell corriendo como Administrador o como el usuario SYSTEM. De igual forma que ocurr\u00eda en Linux, una escalada de privilegios puede ser sencilla o necesitar un detallad\u00edsimo reconocimiento del sistema previamente comprometido. Veamos algunos conceptos b\u00e1sicos a modo de recordatorio. Conceptos previos Cuentas de usuario Las cuentas de usuario se utilizan para iniciar sesi\u00f3n en un sistema Windows. Pensad en una cuenta de usuario como una colecci\u00f3n de configuraciones/preferencias ligado a una identidad \u00fanica. La cuenta de \"Administrador\" local se crea de forma predeterminada en instalaci\u00f3n. Pueden existir varias otras cuentas de usuario predeterminadas (por ejemplo, Invitado) dependiendo de la versi\u00f3n de Windows. Cuentas de servicio Las cuentas de servicio se utilizan, obviamente, para ejecutar servicios en Windows. Las cuentas de servicio NO se pueden utilizar para iniciar sesi\u00f3n en un sistema Windows. La cuenta del SYSTEM es una cuenta de servicio predeterminada que tiene unos mayores privilegios que cualquier cuenta local en Windows. Otras cuentas de servicio predeterminadas incluyen NETWORK SERVICES y LOCAL SERVICE. Grupos Las cuentas de usuario pueden pertenecer a varios grupos y los grupos pueden tener varios usuarios. Los grupos permiten un control de acceso m\u00e1s f\u00e1cil a los recursos. Los grupos regulares (por ejemplo, administradores, usuarios) tienen una lista establecida de miembros. Los pseudogrupos (p. Ej., \"Usuarios autenticados\") tienen una lista din\u00e1mica de miembros que cambia en funci\u00f3n de determinadas interacciones. Recursos En Windows, existen varios tipos de recursos (tambi\u00e9n conocidos como objetos): Archivos / Directorios Entradas de registro Servicios Si un usuario y/o grupo tiene permiso para realizar una determinada acci\u00f3n de un recurso dependerla de la lista de control de acceso (ACL) de ese recurso. ACL y ACE Los permisos para acceder a un determinado recurso en Windows son controlados por la lista de control de acceso (ACL) para ese recurso. Cada ACL se compone de cero o m\u00e1s entradas de control de acceso (ACE). As\u00ed pues, una ACL es una lista ordenada de ACE que define las protecciones que se aplican a un objeto y sus propiedades. Cada ACE identifica una entidad de seguridad y especifica un conjunto de derechos de acceso que est\u00e1n permitidos, denegados o auditados para esa entidad de seguridad. Cuando un usuario intenta acceder a un archivo, el sistema de Windows ejecuta un AccessCheck y compara el descriptor de seguridad con el token de acceso de los usuarios y eval\u00faa si el usuario tiene acceso y qu\u00e9 tipo de acceso seg\u00fan el conjunto de ACE. Cada ACE define la relaci\u00f3n entre un principal (por ejemplo, un usuario, grupo) y un cierto derecho de acceso Ejercicios Cada una de las siguientes escaladas de privilegios la vamos a probar en la sala Windows PrivEsc de Tryhackme a la que deb\u00e9is uniros. Pemisos inseguros de servicios Cada servicio tiene una ACL que define ciertos permisos espec\u00edficos para ese servicio. Algunos permisos son inocuos (por ejemplo, SeRVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS). Algunos pueden resultar \u00fatiles (p. Ej., SERVICE_STOP, SERVICE_START). Algunos son peligrosos (p. Ej., SERVICE_CHANGE_CONFIG, SERVICE_ALL_ACCESS) Si nuestro usuario tiene permiso para cambiar la configuraci\u00f3n de un servicio que se ejecuta con privilegios de SYSTEM, podemos cambiar el ejecutable que utiliza el servicio por uno de nuestra propia cosecha. Potencial callej\u00f3n sin salida: si se puede cambiar la configuraci\u00f3n de un servicio pero no puede reiniciar el servicio, \u00a1no ser\u00e1 posible escalar privilegios! Task 3 de THM Rutas de servicios sin entrecomillado Los ejecutables en Windows se pueden ejecutar sin usar su extensi\u00f3n (por ejemplo, \"whoami.exe\" se puede ejecutar con solo escribir \"whoami\"). Algunos ejecutables aceptan argumentos separados por espacios, p.Ej.: someprog.exe arg1 arg2 arg3 ... Este comportamiento conduce a la ambig\u00fcedad cuando se utilizan rutas absolutas que est\u00e1n sin comillas y contienen espacios. Considered la siguiente ruta sin comillas: C:\\Program FIles\\Algun directorio\\SomeProgram.exe Para nosotros, esto obviamente ejecuta SomeProgram.exe. Para Windows, C:\\Program podr\u00eda ser el ejecutable, con dos argumentos: \"Files\\Algun\" y \"directorio\\SomeProgram.exe\" Windows resuelve esta ambig\u00fcedad comprobando cada una de las posibilidades por turno. Si podemos escribir en una ubicaci\u00f3n que Windows compruebe antes del ejecutable real, podremos enga\u00f1ar al servicio para que lo ejecute. Task 4 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios. Ejecutables de servicios inseguros Si el ejecutable del servicio original es modificable por nuestro usuario, podemos simplemente reemplazarlo con el ejecutable de nuestra shell inversa. \u00a1Recordad crear una copia de seguridad del ejecutable original si se trata de en un sistema real! Task 6 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios. Credenciales almacenadas Windows tiene el comando \" runas \" o \" Ejecutar como \" que permite a los usuarios ejecutar comandos con los privilegios de otros usuarios. Por lo general, esto requiere el conocimiento de la contrase\u00f1a de esos usuarios. Sin embargo, Windows tambi\u00e9n permite a los usuarios guardar sus credenciales en el sistema y estas credenciales guardadas se pueden utilizar para que se omita este requisito. Task 10 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios. Security Account Manager (SAM) Windows almacena hashes de contrase\u00f1a en el Security Account Manager (SAM). Los hashes est\u00e1n cifrados con una clave que se puede encontrar en un archivo llamado SYSTEM. Si se tiene la capacidad de leer los archivos SAM y SYSTEM, se pueden extraer los hashes. Los archivos SAM y SYSTEM se encuentran en el directorio C:\\Windows\\System32\\config . Estps archivos se bloquean mientras se ejecuta Windows. Sin embargo, podr\u00edan existir copias de seguridad de los archivos en los directorios C:\\Windows\\Repair o C:\\Windows\\System32\\config\\RegBack . Task 11 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios. Tareas programadas Windows se puede configurar para ejecutar tareas en momentos concretos, peri\u00f3dicamente (por ejemplo, cada 5 minutos) o cuando se activa por alg\u00fan evento (por ejemplo, un inicio de sesi\u00f3n de usuario). Las tareas generalmente se ejecutan con los privilegios del usuario que las cre\u00f3, sin embargo los administradores pueden configurar tareas para que se ejecuten con los privilegios de otros usuarios, incluido SYSTEM. Task 13 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios.","title":"Escalada de privilegios"},{"location":"section/privesc/#que-es-una-escalada-de-privilegios","text":"La escalada de privilegios ocurre cuando un usuario malicioso o malintencionado aprovecha una vulnerabilidad, un defecto de dise\u00f1o o un error de configuraci\u00f3n en una aplicaci\u00f3n o sistema operativo para obtener un acceso elevado a los recursos que normalmente no deber\u00edan estar disponibles para ellos. El atacante puede usar los privilegios reci\u00e9n obtenidos para robar datos confidenciales, ejecutar comandos administrativos o implementar malware, y potencialmente causar da\u00f1os graves a su sistema operativo, aplicaciones de servidor, organizaci\u00f3n y reputaci\u00f3n Un escenario t\u00edpico donde se produce una escalada de privilegios es cuando un atacante ya ha conseguido comprometer un sistema y ha obtenido un acceso mediante una cuenta con bajos privilegios. Tras este paso inicial el atacante se encuentra con una situaci\u00f3n donde debe obtener mayores privilegios si quiere realmente comprometer todo el sistema u otras partes de la red. As\u00ed pues, digamos que la escalada de privilegios es el paso siguiente tras obtener un punto de entrada inicial al sistema por parte de un atacante.","title":"Qu\u00e9 es una escalada de privilegios?"},{"location":"section/privesc/#tipos-de-escaladas-de-privilegios","text":"Como ya hemos dicho, en general, los atacantes aprovechan las vulnerabilidades de escalamiento de privilegios en la fase de ataque inicial para anular las limitaciones de su cuenta de usuario inicial en un sistema o aplicaci\u00f3n. Hay dos tipos principales de escalada de privilegios: escalada de privilegios horizontal para acceder a la funcionalidad y los datos de un usuario diferente y escalada de privilegios vertical para obtener privilegios elevados, generalmente de un administrador del sistema u otro usuario avanzado. Con la escalada horizontal de privilegios , los actores malintencionados permanecen en el mismo nivel general de privilegios, pero pueden acceder a los datos o la funcionalidad de otras cuentas o procesos que no deber\u00edan estar disponibles para ellos. Por ejemplo, esto puede significar usar un equipo comprometido para obtener acceso a los datos de otros usuarios de la oficina. Para las aplicaciones web, un ejemplo de escalamiento horizontal podr\u00eda ser el uso de secuestro de sesi\u00f3n para evitar la autenticaci\u00f3n y obtener acceso a la cuenta de otro usuario en una red social, una plataforma de comercio electr\u00f3nico o un sitio de banca electr\u00f3nica. M\u00e1s peligrosa es la escalada vertical de privilegios (tambi\u00e9n llamada elevaci\u00f3n de privilegios ), donde el atacante obtiene los derechos de una cuenta con m\u00e1s privilegios, generalmente el administrador o usuario del sistema en Microsoft Windows o root en sistemas Unix y Linux. Con este elevado nivel de acceso, el atacante puede causar todo tipo de estragos en sus sistemas inform\u00e1ticos y aplicaciones: robar credenciales de acceso y datos confidenciales, descargar y ejecutar ransomware, borrar datos o ejecutar c\u00f3digo arbitrario. Los atacantes avanzados utilizar\u00e1n privilegios elevados para cubrir sus pistas eliminando los registros de acceso y otras pruebas de su actividad, sin que la v\u00edctima se d\u00e9 cuenta de que se ha producido un ataque. De esa forma, los ciberdelincuentes pueden robar informaci\u00f3n de forma encubierta y colocar puertas traseras u otro malware en los sistemas de la empresa. Se suelen utilizar 5 m\u00e9todos principalmente para llevar a cabo la escalada de privilegios: Explotaci\u00f3n de credenciales Vulnerabilidades y exploits Configuraciones incorrectas Software malicioso Ingenier\u00eda social","title":"Tipos de escaladas de privilegios"},{"location":"section/privesc/#como-prevenir-y-mitigar-los-ataques-de-escalada-de-privilegios","text":"Debido a que los ataques de escalada de privilegios pueden iniciarese y avanzar de muchas formas diferentes, se requieren m\u00faltiples estrategias y t\u00e1cticas de defensa para protegernos. Sin embargo, la implementaci\u00f3n de un enfoque centrado en la identidad y en controles de administraci\u00f3n de acceso privilegiado permiten protegerse contra la gama m\u00e1s amplia de ataques, as\u00ed como reducir la superficie de ataque. Estas son algunas de las mejores pr\u00e1cticas: Administrar completamente el ciclo de vida de la autenticaci\u00f3n , incluido el aprovisionamiento y desaprovisionamiento de identidades y cuentas para garantizar que no haya cuentas hu\u00e9rfanas que puedan ser secuestradas. Utilizar un mecanismo de administraci\u00f3n de contrase\u00f1as para aplicar pol\u00edticas s\u00f3lidas de administraci\u00f3n de credenciales tanto para humanos como para m\u00e1quinas. Esto tambi\u00e9n implica eliminar la credencial predeterminada y \"hardcodeada\". Aplicar el privilegio m\u00ednimo: eliminar los derechos de administrador de los usuarios y reducir los privilegios de la aplicaci\u00f3n y la m\u00e1quina al m\u00ednimo requerido. Tambi\u00e9n se debe implementar el acceso \"just-in-time\" para reducir los privilegios permanentes o permanentes. Supervisar y administrar todas las sesiones privilegiadas para detectar y abordar r\u00e1pidamente cualquier actividad sospechosa que pueda indicar una cuenta secuestrada o un intento il\u00edcito de escalada de privilegios o movimiento lateral. Fortalecer los sistemas y las aplicaciones: esto complementa el principio de privilegios m\u00ednimos y puede implicar cambios de configuraci\u00f3n, eliminaci\u00f3n de derechos y accesos innecesarios, cierre de puertos y m\u00e1s. Esto mejora la seguridad del sistema y las aplicaciones y ayuda a prevenir y mitigar los errores potenciales que puedan llevar a una vulnerabilidad de inyecci\u00f3n de c\u00f3digo malicioso, desbordamientos de b\u00fafer u otras puertas traseras que podr\u00edan permitir la escalada de privilegios. Gesti\u00f3n de vulnerabilidades: identifique y aborde de forma continua las vulnerabilidades, mediante parches, correcci\u00f3n de configuraciones incorrectas, eliminaci\u00f3n de credenciales predeterminadas y/o integradas, entre otras. El acceso remoto seguro siempre debe monitorearse y administrarse para cualquier forma de acceso privilegiado, ya que los ataques pueden ocurrir horizontal y verticalmente para explotar los privilegios.","title":"\u00bfC\u00f3mo prevenir y mitigar los ataques de escalada de privilegios?"},{"location":"section/privesc/#escalada-de-privilegios-en-linux","text":"En Linux nuestro objetivo con la escalada de privilegios va a ser siempre obetner una shell corriendo con privilegios del usuario root . En muchos casos la escalada de privilegios no recaer\u00e1 simplemente en una simple mala configuraci\u00f3n, sino que requererir\u00e1 combinar varios m\u00e9todos, debilidades y malas configuraciones para conseguirla. Todas las escaladas de privilegios son ejemplos fehacientes de una violaci\u00f3n de los controles de acceso. Puesto ques los controles de acceso y los permisos de usuario est\u00e1n estrechamente ligados, es crucial entender como funcionan los permisos en Linux, tal y como ya hemos visto con anterioridad. Pasemos ahora a ver algunas de las t\u00e9cnicas que permiten la escalada de privilegios en sistemas Linux..","title":"Escalada de privilegios en Linux"},{"location":"section/privesc/#ejercicios","text":"Cada una de las siguientes escaladas de privilegios la vamos a probar en la sala Linux PrivEsc de Tryhackme a la que deb\u00e9is uniros.","title":"Ejercicios"},{"location":"section/privesc/#permisos-debiles-o-incorrectos-en-archivos","text":"Es posible aprovecharse de algunos archivos de sistema para la escalada de privilegios si los permisos de estos archivos son incorrectos. Si un archivo tiene informaci\u00f3n confidencial que podamos leer, podremos usarlo para conseguir el acceso a la cuenta de root. Por otra parte, si nos topamos con un archivo de sistema sobre el que tenemos permisos de escritura, podremos modificar el comportamiento del sistema operativo y obtener acceso root de este modo. Algunos comandos \u00fatiles: Encontrar todos los archivos sobre los que tenemos permiso de escritura en /etc : $ find /etc -maxdepth 1 -writable -type f Encontrar todos los archivos sobre los que tenemos permiso de lectura en /etc : $ find /etc -maxdepth 1 -readable -type f Encontrar todos los directorios sobre los que tenemos permiso de escritura: $ find / -executable -writable -type d 2 > /dev/null Task 3, 4 y 5 de THM El archivo /etc/shadow contiene los hashes de las contrase\u00f1as de usuario, y por de forma predeterminada no es legible por ning\u00fan usuario excepto root. Si podemos leer el contenido del archivo /etc/shadow, podr\u00edamos descifrar el hash de la contrase\u00f1a del usuario root. Si pudi\u00e9ramos modificar el archivo /etc/shadow, podemos reemplazar el hash de la contrase\u00f1a del usuario ra\u00edz con uno que conocemos.","title":"Permisos \"d\u00e9biles\" o incorrectos en archivos"},{"location":"section/privesc/#secuencias-de-escape","text":"En la mayor\u00eda de ocasiones tenemos restricciones para ejecutar \u00fanicamente ciertos programas a trav\u00e9s de sudo. No obstante, puede darse el caso de que pueda \"escapar\" del programa y generar una shell. Cuando un programa se ejecuta con privilegios de root, tambi\u00e9n lo hace la shell que genera, por lo que puedo intentar conseguir una shell a trav\u00e9s de la ejecuci\u00f3n de ese programa. Se puede consultar una lista de programas con sus secuencias de escape correspondientes en GTFObins Procedimiento: Listar los programas que un usuario tiene permitido ejecutar como sudo : $ sudo -l ... ( root ) NOPASSWD: /usr/sbin/iftop ( root ) NOPASSWD: /usr/bin/find ( root ) NOPASSWD: /usr/bin/nano ( root ) NOPASSWD: /usr/bin/vim ( root ) NOPASSWD: /usr/bin/man ( root ) NOPASSWD: /usr/bin/awk ... Para cada programa de la lista, comprobar si existe una secuencia de escape en GTFObins Si existe una secuencia de escapa, ejecutar el programa con sudo e intentar utilizar dcha secuencia para desplegar una shell de root. Task 6 de THM Obt\u00e9n un terminal de root haciendo uso al menos de 3 secuencias de escape diferentes","title":"Secuencias de escape"},{"location":"section/privesc/#tareas-del-cron-y-permisos-de-archivos","text":"Las tareas programadas en el cron son programas o scripts cuyos usuarios pueden programar para que se ejecuten en momentos concretos o a intervalos. Las tareas del cron se ejecutan con el nivel de seguridad del usuario propietario de las mismas. Por defecto, las tareas del cron usan el terminal /bin/bash con determinadas limitaciones. La configuraci\u00f3n de estas tareas se realiza en crontab . Los crontab de los usuarios suelen esar localizados en /var/spool/cron/ o /var/spool/cron/crontabs El crontab del sistema est\u00e1 ubicado en /etc/crontab . Task 8 de THM Consigue una shell de root aprovech\u00e1ndote de la mala configuraci\u00f3n del crontab. Shell inversa Ayuda para entender los conceptos shell directa y shell inversa","title":"Tareas del cron y permisos de archivos"},{"location":"section/privesc/#archivos-de-historial","text":"Los archivos de historial registran los comandos utilizados por los usuarios mientras est\u00e1n usando ciertos programas. Si un usuario escribe una contrase\u00f1a como parte de un comando, esta contrase\u00f1a puede almacenarse en un archivo de historial. Como atacante, siempre es una buena idea intentar cambiar al usuario root con un contrase\u00f1a que ha sido revelada mediante este m\u00e9todo.. Task 16 de THM Consigue una shell de root aprovech\u00e1ndote del historial de comandos.","title":"Archivos de historial"},{"location":"section/privesc/#archivos-de-configuracion","text":"Muchos servicios y programas utilizan archivos de texto (config) para almacenar la configuraci\u00f3n. Si un servicio necesita autenticarse en algo, puede almacenar las credenciales en un archivo de configuraci\u00f3n a pesar de ser una muy mala pr\u00e1ctica. Si se puede acceder a estos archivos de configuraci\u00f3n y los usuarios privilegiados reutilizan las contrase\u00f1as que almacenan, es posible que podamos usarlos para iniciar sesi\u00f3n como ese usuario en otros servicios o sistemas. Task 17 de THM Consigue una shell de root aprovech\u00e1ndote de la informaci\u00f3n encontrada en alg\u00fan archivo de configuraci\u00f3n.","title":"Archivos de configuraci\u00f3n"},{"location":"section/privesc/#claves-ssh","text":"Se pueden utilizar claves SSH en lugar de contrase\u00f1as para autenticar a los usuarios mediante SSH. Las claves SSH vienen en pares: una clave privada y una clave p\u00fablica. La clave privada siempre debe mantenerse en secreto. Si un usuario ha almacenado su clave privada de forma insegura, cualquiera que pueda leer la clave puede iniciar sesi\u00f3n en su cuenta us\u00e1ndola. Task 18 de THM Consigue una shell de root aprovech\u00e1ndote de las claves SSH del sistema.","title":"Claves SSH"},{"location":"section/privesc/#escalada-de-privilegios-en-windows","text":"En una escalada de privilegios en Windows nuestro objetivo ser\u00e1 obtener una shell corriendo como Administrador o como el usuario SYSTEM. De igual forma que ocurr\u00eda en Linux, una escalada de privilegios puede ser sencilla o necesitar un detallad\u00edsimo reconocimiento del sistema previamente comprometido. Veamos algunos conceptos b\u00e1sicos a modo de recordatorio.","title":"Escalada de privilegios en Windows"},{"location":"section/privesc/#conceptos-previos","text":"","title":"Conceptos previos"},{"location":"section/privesc/#cuentas-de-usuario","text":"Las cuentas de usuario se utilizan para iniciar sesi\u00f3n en un sistema Windows. Pensad en una cuenta de usuario como una colecci\u00f3n de configuraciones/preferencias ligado a una identidad \u00fanica. La cuenta de \"Administrador\" local se crea de forma predeterminada en instalaci\u00f3n. Pueden existir varias otras cuentas de usuario predeterminadas (por ejemplo, Invitado) dependiendo de la versi\u00f3n de Windows.","title":"Cuentas de usuario"},{"location":"section/privesc/#cuentas-de-servicio","text":"Las cuentas de servicio se utilizan, obviamente, para ejecutar servicios en Windows. Las cuentas de servicio NO se pueden utilizar para iniciar sesi\u00f3n en un sistema Windows. La cuenta del SYSTEM es una cuenta de servicio predeterminada que tiene unos mayores privilegios que cualquier cuenta local en Windows. Otras cuentas de servicio predeterminadas incluyen NETWORK SERVICES y LOCAL SERVICE.","title":"Cuentas de servicio"},{"location":"section/privesc/#grupos","text":"Las cuentas de usuario pueden pertenecer a varios grupos y los grupos pueden tener varios usuarios. Los grupos permiten un control de acceso m\u00e1s f\u00e1cil a los recursos. Los grupos regulares (por ejemplo, administradores, usuarios) tienen una lista establecida de miembros. Los pseudogrupos (p. Ej., \"Usuarios autenticados\") tienen una lista din\u00e1mica de miembros que cambia en funci\u00f3n de determinadas interacciones.","title":"Grupos"},{"location":"section/privesc/#recursos","text":"En Windows, existen varios tipos de recursos (tambi\u00e9n conocidos como objetos): Archivos / Directorios Entradas de registro Servicios Si un usuario y/o grupo tiene permiso para realizar una determinada acci\u00f3n de un recurso dependerla de la lista de control de acceso (ACL) de ese recurso.","title":"Recursos"},{"location":"section/privesc/#acl-y-ace","text":"Los permisos para acceder a un determinado recurso en Windows son controlados por la lista de control de acceso (ACL) para ese recurso. Cada ACL se compone de cero o m\u00e1s entradas de control de acceso (ACE). As\u00ed pues, una ACL es una lista ordenada de ACE que define las protecciones que se aplican a un objeto y sus propiedades. Cada ACE identifica una entidad de seguridad y especifica un conjunto de derechos de acceso que est\u00e1n permitidos, denegados o auditados para esa entidad de seguridad. Cuando un usuario intenta acceder a un archivo, el sistema de Windows ejecuta un AccessCheck y compara el descriptor de seguridad con el token de acceso de los usuarios y eval\u00faa si el usuario tiene acceso y qu\u00e9 tipo de acceso seg\u00fan el conjunto de ACE. Cada ACE define la relaci\u00f3n entre un principal (por ejemplo, un usuario, grupo) y un cierto derecho de acceso","title":"ACL y ACE"},{"location":"section/privesc/#ejercicios_1","text":"Cada una de las siguientes escaladas de privilegios la vamos a probar en la sala Windows PrivEsc de Tryhackme a la que deb\u00e9is uniros.","title":"Ejercicios"},{"location":"section/privesc/#pemisos-inseguros-de-servicios","text":"Cada servicio tiene una ACL que define ciertos permisos espec\u00edficos para ese servicio. Algunos permisos son inocuos (por ejemplo, SeRVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS). Algunos pueden resultar \u00fatiles (p. Ej., SERVICE_STOP, SERVICE_START). Algunos son peligrosos (p. Ej., SERVICE_CHANGE_CONFIG, SERVICE_ALL_ACCESS) Si nuestro usuario tiene permiso para cambiar la configuraci\u00f3n de un servicio que se ejecuta con privilegios de SYSTEM, podemos cambiar el ejecutable que utiliza el servicio por uno de nuestra propia cosecha. Potencial callej\u00f3n sin salida: si se puede cambiar la configuraci\u00f3n de un servicio pero no puede reiniciar el servicio, \u00a1no ser\u00e1 posible escalar privilegios! Task 3 de THM","title":"Pemisos inseguros de servicios"},{"location":"section/privesc/#rutas-de-servicios-sin-entrecomillado","text":"Los ejecutables en Windows se pueden ejecutar sin usar su extensi\u00f3n (por ejemplo, \"whoami.exe\" se puede ejecutar con solo escribir \"whoami\"). Algunos ejecutables aceptan argumentos separados por espacios, p.Ej.: someprog.exe arg1 arg2 arg3 ... Este comportamiento conduce a la ambig\u00fcedad cuando se utilizan rutas absolutas que est\u00e1n sin comillas y contienen espacios. Considered la siguiente ruta sin comillas: C:\\Program FIles\\Algun directorio\\SomeProgram.exe Para nosotros, esto obviamente ejecuta SomeProgram.exe. Para Windows, C:\\Program podr\u00eda ser el ejecutable, con dos argumentos: \"Files\\Algun\" y \"directorio\\SomeProgram.exe\" Windows resuelve esta ambig\u00fcedad comprobando cada una de las posibilidades por turno. Si podemos escribir en una ubicaci\u00f3n que Windows compruebe antes del ejecutable real, podremos enga\u00f1ar al servicio para que lo ejecute. Task 4 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios.","title":"Rutas de servicios sin entrecomillado"},{"location":"section/privesc/#ejecutables-de-servicios-inseguros","text":"Si el ejecutable del servicio original es modificable por nuestro usuario, podemos simplemente reemplazarlo con el ejecutable de nuestra shell inversa. \u00a1Recordad crear una copia de seguridad del ejecutable original si se trata de en un sistema real! Task 6 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios.","title":"Ejecutables de servicios inseguros"},{"location":"section/privesc/#credenciales-almacenadas","text":"Windows tiene el comando \" runas \" o \" Ejecutar como \" que permite a los usuarios ejecutar comandos con los privilegios de otros usuarios. Por lo general, esto requiere el conocimiento de la contrase\u00f1a de esos usuarios. Sin embargo, Windows tambi\u00e9n permite a los usuarios guardar sus credenciales en el sistema y estas credenciales guardadas se pueden utilizar para que se omita este requisito. Task 10 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios.","title":"Credenciales almacenadas"},{"location":"section/privesc/#security-account-manager-sam","text":"Windows almacena hashes de contrase\u00f1a en el Security Account Manager (SAM). Los hashes est\u00e1n cifrados con una clave que se puede encontrar en un archivo llamado SYSTEM. Si se tiene la capacidad de leer los archivos SAM y SYSTEM, se pueden extraer los hashes. Los archivos SAM y SYSTEM se encuentran en el directorio C:\\Windows\\System32\\config . Estps archivos se bloquean mientras se ejecuta Windows. Sin embargo, podr\u00edan existir copias de seguridad de los archivos en los directorios C:\\Windows\\Repair o C:\\Windows\\System32\\config\\RegBack . Task 11 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios.","title":"Security Account Manager (SAM)"},{"location":"section/privesc/#tareas-programadas","text":"Windows se puede configurar para ejecutar tareas en momentos concretos, peri\u00f3dicamente (por ejemplo, cada 5 minutos) o cuando se activa por alg\u00fan evento (por ejemplo, un inicio de sesi\u00f3n de usuario). Las tareas generalmente se ejecutan con los privilegios del usuario que las cre\u00f3, sin embargo los administradores pueden configurar tareas para que se ejecuten con los privilegios de otros usuarios, incluido SYSTEM. Task 13 de THM Obt\u00e9n una shell de Administrador haciendo uso de esta escalada de privilegios.","title":"Tareas programadas"},{"location":"section/webgrafia/","text":"\u00c1rbol de directorios en Linux Archwiki - Usuarios y grupos Manuel Mujica -Permisos Linux Linux.com -File permissions baeldung.com - Advanced Permissions in Linux geeksforgeeks.com - Permissions in Linux The command line for beginners The hacker way - Pentesting AD Microsoft - AD GPOs Escalada de privilegios","title":"Webgraf\u00eda"}]}